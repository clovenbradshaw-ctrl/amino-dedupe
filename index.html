<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Airtable Dedupe - Deduplication Tool</title>
  <script src="https://unpkg.com/react@18/umd/react.production.min.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js" crossorigin></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/fuse.js@7.0.0"></script>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
      min-height: 100vh;
      color: #e2e8f0;
    }
    .container { max-width: 1600px; margin: 0 auto; padding: 20px; }
    h1 { color: #a5b4fc; margin-bottom: 10px; }
    .subtitle { color: #94a3b8; margin-bottom: 20px; }

    .card {
      background: rgba(30, 41, 59, 0.8);
      border: 1px solid #334155;
      border-radius: 12px;
      padding: 20px;
      margin-bottom: 20px;
    }
    .card h2 { color: #a5b4fc; margin-bottom: 15px; font-size: 1.2em; }
    .card h3 { color: #94a3b8; margin-bottom: 10px; font-size: 1em; }

    .input-group { margin-bottom: 15px; }
    .input-group label { display: block; margin-bottom: 5px; color: #94a3b8; }
    input[type="text"], input[type="password"], input[type="date"], select, textarea {
      width: 100%;
      padding: 10px;
      border: 1px solid #475569;
      border-radius: 6px;
      background: #1e293b;
      color: #e2e8f0;
    }
    input[type="date"]::-webkit-calendar-picker-indicator {
      filter: invert(0.8);
      cursor: pointer;
    }
    input:focus, select:focus, textarea:focus { outline: none; border-color: #6366f1; }

    button {
      padding: 10px 20px;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 0.9em;
      transition: all 0.2s;
    }
    button.primary { background: #6366f1; color: white; }
    button.primary:hover { background: #4f46e5; }
    button.success { background: #10b981; color: white; }
    button.success:hover { background: #059669; }
    button.warning { background: #f59e0b; color: white; }
    button.warning:hover { background: #d97706; }
    button.danger { background: #ef4444; color: white; }
    button.danger:hover { background: #dc2626; }
    button.secondary { background: #475569; color: white; }
    button.secondary:hover { background: #64748b; }
    button:disabled { background: #475569; cursor: not-allowed; opacity: 0.6; }
    button.small { padding: 6px 12px; font-size: 0.8em; }

    .btn-group { display: flex; gap: 10px; flex-wrap: wrap; margin-top: 15px; }

    .stats-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
      gap: 15px;
      margin: 15px 0;
    }
    .stat-card {
      background: #1e293b;
      border: 1px solid #334155;
      border-radius: 8px;
      padding: 15px;
      text-align: center;
    }
    .stat-card .number { font-size: 1.8em; font-weight: bold; color: #10b981; }
    .stat-card .label { color: #94a3b8; font-size: 0.85em; }
    .stat-card.tier1 .number { color: #10b981; }
    .stat-card.tier2 .number { color: #6366f1; }
    .stat-card.tier3 .number { color: #f59e0b; }
    .stat-card.tier4 .number { color: #ef4444; }

    .table-container { overflow-x: auto; margin: 15px 0; max-height: 500px; overflow-y: auto; }
    table { width: 100%; border-collapse: collapse; font-size: 0.85em; }
    th, td { padding: 10px; text-align: left; border-bottom: 1px solid #334155; }
    th { background: #1e293b; position: sticky; top: 0; color: #a5b4fc; z-index: 10; }
    tr:hover { background: rgba(99, 102, 241, 0.1); }
    tr.clickable { cursor: pointer; }
    tr.clickable:hover { background: rgba(99, 102, 241, 0.2); }
    tr.selected { background: rgba(99, 102, 241, 0.25); }
    tr.selected:hover { background: rgba(99, 102, 241, 0.35); }

    .badge {
      display: inline-block;
      padding: 2px 8px;
      border-radius: 4px;
      font-size: 0.8em;
      font-weight: 500;
    }
    .badge.tier1 { background: #10b981; color: white; }
    .badge.tier2 { background: #6366f1; color: white; }
    .badge.tier3 { background: #f59e0b; color: white; }
    .badge.tier4 { background: #ef4444; color: white; }
    .badge.keep { background: #10b981; color: white; }
    .badge.merge { background: #f59e0b; color: white; }

    .log-container {
      background: #0f172a;
      border: 1px solid #334155;
      border-radius: 8px;
      padding: 15px;
      max-height: 250px;
      overflow-y: auto;
      font-family: monospace;
      font-size: 0.8em;
    }
    .log-entry { padding: 3px 0; border-bottom: 1px solid #1e293b; }
    .log-entry.info { color: #6366f1; }
    .log-entry.success { color: #10b981; }
    .log-entry.warning { color: #f59e0b; }
    .log-entry.error { color: #ef4444; }

    .progress-bar {
      background: #1e293b;
      border-radius: 4px;
      height: 8px;
      overflow: hidden;
      margin: 10px 0;
    }
    .progress-bar .fill {
      height: 100%;
      background: linear-gradient(90deg, #6366f1, #10b981);
      transition: width 0.3s;
    }

    .tabs { display: flex; gap: 5px; margin-bottom: 15px; flex-wrap: wrap; }
    .tab {
      padding: 10px 20px;
      background: #1e293b;
      border: 1px solid #334155;
      border-radius: 6px 6px 0 0;
      cursor: pointer;
      color: #94a3b8;
    }
    .tab.active { background: #334155; color: #a5b4fc; border-bottom-color: #334155; }

    .filter-controls {
      display: flex;
      gap: 15px;
      flex-wrap: wrap;
      margin-bottom: 15px;
      align-items: center;
    }
    .filter-controls select {
      width: auto;
      min-width: 150px;
    }
    .filter-controls input[type="text"] {
      width: auto;
      min-width: 200px;
    }

    .checkbox-label {
      display: flex;
      align-items: center;
      gap: 8px;
      cursor: pointer;
      color: #94a3b8;
    }
    .checkbox-label input { width: 18px; height: 18px; }

    /* Match reasons */
    .reason-tag {
      display: inline-block;
      background: #1e293b;
      padding: 2px 8px;
      border-radius: 4px;
      font-size: 0.75em;
      color: #94a3b8;
      margin: 2px;
    }
    .reason-tag.conflict {
      background: rgba(239, 68, 68, 0.2);
      border: 1px solid #ef4444;
      color: #ef4444;
    }

    /* Diff View */
    .diff-container {
      display: grid;
      grid-template-columns: 200px 1fr 1fr 150px;
      gap: 1px;
      background: #334155;
      border-radius: 8px;
      overflow: hidden;
      margin: 15px 0;
    }
    .diff-header {
      background: #1e293b;
      padding: 12px;
      font-weight: bold;
      color: #a5b4fc;
    }
    .diff-row {
      display: contents;
    }
    .diff-row:hover > div { background: rgba(99, 102, 241, 0.1); }
    .diff-cell {
      background: rgba(30, 41, 59, 0.9);
      padding: 10px;
      border-bottom: 1px solid #334155;
      font-size: 0.85em;
      word-break: break-word;
    }
    .diff-cell.field-name {
      font-weight: 500;
      color: #94a3b8;
    }
    .diff-cell.computed {
      opacity: 0.5;
      font-style: italic;
    }
    .diff-cell.different { background: rgba(245, 158, 11, 0.1); }
    .diff-cell.same { background: rgba(16, 185, 129, 0.05); }
    .diff-cell.selected { background: rgba(99, 102, 241, 0.2); border: 2px solid #6366f1; }
    .diff-cell.clickable { cursor: pointer; }
    .diff-cell.clickable:hover { background: rgba(99, 102, 241, 0.15); }
    .empty-value { color: #64748b; font-style: italic; }

    .pick-buttons {
      display: flex;
      gap: 5px;
    }
    .pick-btn {
      padding: 4px 10px;
      border: 1px solid #475569;
      background: #1e293b;
      color: #94a3b8;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.8em;
    }
    .pick-btn:hover { background: #334155; }
    .pick-btn.active { background: #6366f1; border-color: #6366f1; color: white; }
    .pick-btn.auto { background: #0f172a; color: #64748b; cursor: default; }

    /* Modal */
    .modal-overlay {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0, 0, 0, 0.8);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }
    .modal {
      background: #1e293b;
      border: 1px solid #475569;
      border-radius: 12px;
      width: 90%;
      max-width: 1200px;
      max-height: 90vh;
      overflow: hidden;
      display: flex;
      flex-direction: column;
    }
    .modal-header {
      padding: 20px;
      border-bottom: 1px solid #334155;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .modal-header h2 { margin: 0; }
    .modal-close {
      background: none;
      border: none;
      color: #94a3b8;
      font-size: 1.5em;
      cursor: pointer;
      padding: 5px 10px;
    }
    .modal-close:hover { color: #e2e8f0; }
    .modal-body {
      padding: 20px;
      overflow-y: auto;
      flex: 1;
    }
    .modal-footer {
      padding: 15px 20px;
      border-top: 1px solid #334155;
      display: flex;
      justify-content: flex-end;
      gap: 10px;
    }

    /* Confidence meter */
    .confidence-meter {
      display: flex;
      align-items: center;
      gap: 10px;
    }
    .confidence-bar {
      flex: 1;
      height: 8px;
      background: #0f172a;
      border-radius: 4px;
      overflow: hidden;
    }
    .confidence-fill {
      height: 100%;
      border-radius: 4px;
    }
    .confidence-fill.tier1 { background: #10b981; }
    .confidence-fill.tier2 { background: #6366f1; }
    .confidence-fill.tier3 { background: #f59e0b; }
    .confidence-fill.tier4 { background: #ef4444; }

    /* History */
    .history-event {
      background: #0f172a;
      border: 1px solid #334155;
      border-radius: 12px;
      margin-bottom: 15px;
      overflow: hidden;
    }
    .history-event-header {
      padding: 15px 20px;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 15px;
    }
    .history-event-header:hover { background: #1e293b; }
    .history-event.merge { border-left: 4px solid #6366f1; }
    .history-event.unmerge { border-left: 4px solid #f59e0b; }
    .history-event-body {
      padding: 20px;
      border-top: 1px solid #334155;
      background: #1e293b;
    }
    .history-event-body pre {
      background: #0f172a;
      padding: 10px;
      border-radius: 6px;
      overflow-x: auto;
      font-size: 0.8em;
      max-height: 200px;
      overflow-y: auto;
    }

    /* Enhanced History Styles */
    .history-summary {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 15px;
      margin-bottom: 20px;
    }
    .history-summary-item {
      background: rgba(99, 102, 241, 0.1);
      border: 1px solid rgba(99, 102, 241, 0.3);
      border-radius: 8px;
      padding: 15px;
    }
    .history-summary-item .label {
      font-size: 0.75em;
      color: #94a3b8;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: 5px;
    }
    .history-summary-item .value {
      font-size: 1.1em;
      color: #e2e8f0;
      font-weight: 500;
    }
    .merged-record-card {
      background: rgba(245, 158, 11, 0.1);
      border: 1px solid rgba(245, 158, 11, 0.3);
      border-radius: 8px;
      padding: 15px;
      margin-bottom: 15px;
    }
    .merged-record-card h4 {
      color: #f59e0b;
      margin-bottom: 10px;
      font-size: 0.9em;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .field-changes-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.85em;
      margin-top: 10px;
    }
    .field-changes-table th {
      text-align: left;
      padding: 8px 10px;
      background: rgba(30, 41, 59, 0.5);
      color: #94a3b8;
      font-weight: 500;
      border-bottom: 1px solid #334155;
    }
    .field-changes-table td {
      padding: 8px 10px;
      border-bottom: 1px solid #1e293b;
      word-break: break-word;
    }
    .field-changes-table tr:hover td {
      background: rgba(99, 102, 241, 0.05);
    }
    .history-icon {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.3em;
      flex-shrink: 0;
    }
    .history-icon.merge-icon {
      background: rgba(99, 102, 241, 0.2);
    }
    .history-icon.unmerge-icon {
      background: rgba(245, 158, 11, 0.2);
    }
    .history-tabs {
      display: flex;
      gap: 5px;
      margin-bottom: 15px;
      border-bottom: 1px solid #334155;
      padding-bottom: 10px;
    }
    .history-tab {
      padding: 8px 16px;
      background: transparent;
      border: none;
      color: #94a3b8;
      cursor: pointer;
      border-radius: 6px 6px 0 0;
      font-size: 0.85em;
    }
    .history-tab:hover {
      background: rgba(99, 102, 241, 0.1);
    }
    .history-tab.active {
      background: rgba(99, 102, 241, 0.2);
      color: #a5b4fc;
    }

    /* Match Settings Panel */
    .match-settings-panel {
      background: rgba(30, 41, 59, 0.9);
      border: 1px solid #334155;
      border-radius: 12px;
      margin-bottom: 20px;
      overflow: hidden;
    }
    .match-settings-header {
      padding: 15px 20px;
      background: #1e293b;
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
      user-select: none;
    }
    .match-settings-header:hover {
      background: #253346;
    }
    .match-settings-header h3 {
      margin: 0;
      color: #a5b4fc;
      font-size: 1em;
      display: flex;
      align-items: center;
      gap: 10px;
    }
    .match-settings-toggle {
      color: #94a3b8;
      font-size: 1.2em;
      transition: transform 0.2s;
    }
    .match-settings-toggle.expanded {
      transform: rotate(180deg);
    }
    .match-settings-body {
      padding: 20px;
      border-top: 1px solid #334155;
    }
    .match-settings-presets {
      display: flex;
      gap: 10px;
      margin-bottom: 20px;
      flex-wrap: wrap;
    }
    .preset-btn {
      padding: 8px 16px;
      border: 1px solid #475569;
      background: #1e293b;
      color: #94a3b8;
      border-radius: 6px;
      cursor: pointer;
      font-size: 0.85em;
      transition: all 0.2s;
    }
    .preset-btn:hover {
      background: #334155;
      border-color: #6366f1;
    }
    .preset-btn.active {
      background: #6366f1;
      border-color: #6366f1;
      color: white;
    }
    .match-field-section {
      margin-bottom: 20px;
    }
    .match-field-section-title {
      font-size: 0.85em;
      color: #94a3b8;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: 12px;
      padding-bottom: 8px;
      border-bottom: 1px solid #334155;
    }
    .match-field-row {
      display: flex;
      align-items: center;
      gap: 15px;
      padding: 10px 0;
      border-bottom: 1px solid rgba(51, 65, 85, 0.5);
    }
    .match-field-row:last-child {
      border-bottom: none;
    }
    .match-field-toggle {
      display: flex;
      align-items: center;
      gap: 10px;
      min-width: 180px;
    }
    .match-field-toggle input[type="checkbox"] {
      width: 18px;
      height: 18px;
      cursor: pointer;
    }
    .match-field-toggle label {
      cursor: pointer;
      color: #e2e8f0;
      font-size: 0.9em;
    }
    .match-field-toggle.disabled label {
      color: #64748b;
    }
    .match-field-controls {
      display: flex;
      align-items: center;
      gap: 15px;
      flex: 1;
    }
    .match-type-select {
      min-width: 140px;
      padding: 6px 10px;
      font-size: 0.85em;
    }
    .threshold-slider {
      display: flex;
      align-items: center;
      gap: 10px;
      flex: 1;
      max-width: 250px;
    }
    .threshold-slider input[type="range"] {
      flex: 1;
      height: 6px;
      -webkit-appearance: none;
      background: #334155;
      border-radius: 3px;
      cursor: pointer;
    }
    .threshold-slider input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: #6366f1;
      cursor: pointer;
    }
    .threshold-slider input[type="range"]::-moz-range-thumb {
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: #6366f1;
      cursor: pointer;
      border: none;
    }
    .threshold-value {
      min-width: 45px;
      text-align: center;
      font-size: 0.85em;
      color: #a5b4fc;
      font-weight: 500;
    }
    .field-badge {
      font-size: 0.7em;
      padding: 2px 6px;
      border-radius: 3px;
      margin-left: 8px;
    }
    .field-badge.recommended {
      background: rgba(16, 185, 129, 0.2);
      color: #10b981;
    }
    .field-badge.blocking {
      background: rgba(239, 68, 68, 0.2);
      color: #ef4444;
    }
    .field-badge.id {
      background: rgba(99, 102, 241, 0.2);
      color: #a5b4fc;
    }
    .match-settings-footer {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding-top: 15px;
      border-top: 1px solid #334155;
      margin-top: 10px;
    }
    .settings-info {
      font-size: 0.8em;
      color: #64748b;
    }
    .expand-toggle {
      background: none;
      border: none;
      color: #6366f1;
      cursor: pointer;
      font-size: 0.85em;
      padding: 5px 10px;
    }
    .expand-toggle:hover {
      text-decoration: underline;
    }
    .field-tooltip {
      position: relative;
      display: inline-block;
      margin-left: 5px;
      cursor: help;
    }
    .field-tooltip .tooltip-icon {
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: #334155;
      color: #94a3b8;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 0.7em;
      font-weight: bold;
    }
    .field-tooltip .tooltip-text {
      visibility: hidden;
      width: 220px;
      background: #0f172a;
      color: #e2e8f0;
      text-align: left;
      border-radius: 6px;
      padding: 10px;
      position: absolute;
      z-index: 100;
      bottom: 125%;
      left: 50%;
      margin-left: -110px;
      font-size: 0.8em;
      line-height: 1.4;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
      border: 1px solid #334155;
    }
    .field-tooltip:hover .tooltip-text {
      visibility: visible;
    }
  </style>
</head>
<body>
  <div id="root"></div>
  <script type="text/babel">
const { useState, useCallback, useEffect, useRef, useMemo } = React;

// ============================================
// CONFIGURATION
// ============================================

const AIRTABLE_BASE_ID = 'app1tsUyKa7F3sy0D';
const CLIENT_INFO_TABLE = 'Client Info';
const CASE_MASTER_VIEW_TABLE = 'tblgynOzESGvAXAsK'; // Case Master View table ID

// Table configurations - defines which tables are available and their settings
const TABLE_CONFIGS = {
  client_info: {
    id: 'client_info',
    name: 'Client Info',
    tableId: CLIENT_INFO_TABLE,
    description: 'Nashville PP client records with Box folder integration',
    icon: 'ðŸ‘¤',
    flatpackField: null,
    hasBahrFilter: true,
    historyField: 'dedupe_history',
    excludeFromMerge: ['Box Legacy ID'],
    // Uses the main MATCH_FIELD_DEFINITIONS
    useMainMatchFields: true,
  },
  case_master_view: {
    id: 'case_master_view',
    name: 'Case Master View',
    tableId: CASE_MASTER_VIEW_TABLE,
    description: 'Case tracking with Clio integration via Matter_Flatpack',
    icon: 'ðŸ“‹',
    flatpackField: 'Matter_Flatpack',
    hasBahrFilter: false, // Bahr detection is via matterId in flatpack
    historyField: 'Matter_Flatpack', // History stored in flatpack as events
    excludeFromMerge: [],
    useMainMatchFields: false,
    // Custom match fields for Case Master View
    matchFieldDefinitions: {
      name: {
        id: 'name',
        label: 'Name / Client Name',
        category: 'primary',
        description: 'Compares Name field and clientName from Matter_Flatpack',
        airtableFields: ['Name', 'Client Name', 'Defendant Name'],
        flatpackFields: ['clientName'],
        defaultEnabled: true,
        defaultType: 'fuzzy',
        defaultThreshold: 70,
        supportsFuzzy: true,
        recommended: true,
      },
      matterId: {
        id: 'matterId',
        label: 'Matter ID (Clio)',
        category: 'identity',
        description: 'Exact match on Clio Matter ID from flatpack - definitive',
        flatpackFields: ['matterId'],
        defaultEnabled: true,
        defaultType: 'exact',
        defaultThreshold: 100,
        supportsFuzzy: false,
        badge: 'id',
      },
      ppid: {
        id: 'ppid',
        label: 'PP_ID',
        category: 'identity',
        description: 'Nashville PP system ID - exact match is definitive',
        airtableFields: ['PP_ID'],
        defaultEnabled: true,
        defaultType: 'exact',
        defaultThreshold: 100,
        supportsFuzzy: false,
        badge: 'id',
      },
      clioId: {
        id: 'clioId',
        label: 'Clio_ID / Client_ID',
        category: 'identity',
        description: 'Clio client ID fields',
        airtableFields: ['Clio_ID', 'Client_ID_Airtable'],
        flatpackFields: ['clientId'],
        defaultEnabled: true,
        defaultType: 'exact',
        defaultThreshold: 100,
        supportsFuzzy: false,
        badge: 'id',
      },
      phone: {
        id: 'phone',
        label: 'Phone',
        category: 'contact',
        description: 'Phone number comparison (normalized)',
        airtableFields: ['Phone'],
        defaultEnabled: true,
        defaultType: 'normalized',
        defaultThreshold: 100,
        supportsFuzzy: true,
      },
      email: {
        id: 'email',
        label: 'Email',
        category: 'contact',
        description: 'Email address comparison',
        airtableFields: ['Email'],
        defaultEnabled: true,
        defaultType: 'exact',
        defaultThreshold: 100,
        supportsFuzzy: true,
      },
      dob: {
        id: 'dob',
        label: 'DOB',
        category: 'personal',
        description: 'Date of birth - strong corroboration',
        airtableFields: ['DOB'],
        defaultEnabled: true,
        defaultType: 'exact',
        defaultThreshold: 100,
        supportsFuzzy: false,
      },
      address: {
        id: 'address',
        label: 'Address',
        category: 'additional',
        description: 'Street address comparison',
        airtableFields: ['Address'],
        defaultEnabled: false,
        defaultType: 'fuzzy',
        defaultThreshold: 80,
        supportsFuzzy: true,
      },
    },
    // Fields to concatenate on merge
    concatenateFields: ['Notes', 'Case Notes', 'History'],
  },
};

// Password hashes for authentication
const ALL_CLIENTS_HASH = '66a0dda85ec791a862a57ac9d0ffca6a3aa3310cbe367ff2cd73e29dde2b0abd';
const BAHR_ONLY_HASH = '472e01695e25f97cfc5d3418bd69628c485e539247712436973c2802f7c409bd';

// Match tier definitions
const MATCH_TIERS = {
  TIER1: { tier: 1, name: 'Definitive', color: '#10b981', minConfidence: 100 },
  TIER2: { tier: 2, name: 'Strong', color: '#6366f1', minConfidence: 85 },
  TIER3: { tier: 3, name: 'Possible', color: '#f59e0b', minConfidence: 70 },
  TIER4: { tier: 4, name: 'Investigate', color: '#ef4444', minConfidence: 0 },
};

// Fields to exclude from merging
const EXCLUDE_FROM_MERGE = ['Box Legacy ID'];

// ============================================
// MATCH CONFIGURATION
// ============================================

// Field definitions for match configuration
const MATCH_FIELD_DEFINITIONS = {
  // Primary Name Matching
  name: {
    id: 'name',
    label: 'Name',
    category: 'primary',
    description: 'Compares First Name + Family Name using fuzzy matching, nicknames, and exact match',
    defaultEnabled: true,
    defaultType: 'fuzzy',
    defaultThreshold: 85,
    supportsFuzzy: true,
    recommended: true,
  },
  // Identity Fields
  ppid: {
    id: 'ppid',
    label: 'PPID',
    category: 'identity',
    description: 'Primary Person ID - exact match gives high confidence',
    defaultEnabled: true,
    defaultType: 'exact',
    defaultThreshold: 100,
    supportsFuzzy: false,
    badge: 'id',
  },
  aNumber: {
    id: 'aNumber',
    label: 'A#',
    category: 'identity',
    description: 'Alien Number - exact match gives high confidence',
    defaultEnabled: true,
    defaultType: 'exact',
    defaultThreshold: 100,
    supportsFuzzy: false,
    badge: 'id',
  },
  clioId: {
    id: 'clioId',
    label: 'Clio Contact ID',
    category: 'identity',
    description: 'Different Clio IDs means records are definitely NOT the same person',
    defaultEnabled: true,
    defaultType: 'blocking',
    defaultThreshold: 100,
    supportsFuzzy: false,
    badge: 'blocking',
    isBlocking: true,
  },
  // Contact Fields
  phone: {
    id: 'phone',
    label: 'Phone Number',
    category: 'contact',
    description: 'Phone numbers are normalized to 10 digits before comparison',
    defaultEnabled: true,
    defaultType: 'normalized',
    defaultThreshold: 100,
    supportsFuzzy: true,
    recommended: true,
  },
  email: {
    id: 'email',
    label: 'Email',
    category: 'contact',
    description: 'Email comparison (ignores null@blank placeholder emails)',
    defaultEnabled: true,
    defaultType: 'exact',
    defaultThreshold: 100,
    supportsFuzzy: true,
  },
  // Personal Fields
  dob: {
    id: 'dob',
    label: 'Date of Birth',
    category: 'personal',
    description: 'Exact date match - strong corroborating evidence',
    defaultEnabled: true,
    defaultType: 'exact',
    defaultThreshold: 100,
    supportsFuzzy: false,
    recommended: true,
  },
  // Additional Fields (collapsed by default)
  address: {
    id: 'address',
    label: 'Address',
    category: 'additional',
    description: 'Street address comparison',
    defaultEnabled: false,
    defaultType: 'fuzzy',
    defaultThreshold: 80,
    supportsFuzzy: true,
  },
  city: {
    id: 'city',
    label: 'City',
    category: 'additional',
    description: 'City name comparison',
    defaultEnabled: false,
    defaultType: 'exact',
    defaultThreshold: 100,
    supportsFuzzy: true,
  },
  state: {
    id: 'state',
    label: 'State',
    category: 'additional',
    description: 'State comparison',
    defaultEnabled: false,
    defaultType: 'exact',
    defaultThreshold: 100,
    supportsFuzzy: false,
  },
  country: {
    id: 'country',
    label: 'Country',
    category: 'additional',
    description: 'Country comparison',
    defaultEnabled: false,
    defaultType: 'exact',
    defaultThreshold: 100,
    supportsFuzzy: false,
  },
};

// Match type options
const MATCH_TYPES = {
  exact: { id: 'exact', label: 'Exact Match', description: 'Values must be identical' },
  fuzzy: { id: 'fuzzy', label: 'Fuzzy Match', description: 'Allows similar values based on threshold' },
  normalized: { id: 'normalized', label: 'Normalized', description: 'Normalizes format before comparing' },
  blocking: { id: 'blocking', label: 'Blocking', description: 'Different values = definitely not a match' },
};

// Preset configurations
const MATCH_PRESETS = {
  conservative: {
    id: 'conservative',
    name: 'Conservative',
    description: 'High confidence only - exact names + ID matches',
    config: {
      name: { enabled: true, type: 'fuzzy', threshold: 95 },
      ppid: { enabled: true, type: 'exact', threshold: 100 },
      aNumber: { enabled: true, type: 'exact', threshold: 100 },
      clioId: { enabled: true, type: 'blocking', threshold: 100 },
      phone: { enabled: true, type: 'normalized', threshold: 100 },
      email: { enabled: true, type: 'exact', threshold: 100 },
      dob: { enabled: true, type: 'exact', threshold: 100 },
      address: { enabled: false, type: 'fuzzy', threshold: 90 },
      city: { enabled: false, type: 'exact', threshold: 100 },
      state: { enabled: false, type: 'exact', threshold: 100 },
      country: { enabled: false, type: 'exact', threshold: 100 },
    },
    minConfidenceForMatch: 85,
  },
  balanced: {
    id: 'balanced',
    name: 'Balanced',
    description: 'Default settings - good balance of precision and recall',
    config: {
      name: { enabled: true, type: 'fuzzy', threshold: 85 },
      ppid: { enabled: true, type: 'exact', threshold: 100 },
      aNumber: { enabled: true, type: 'exact', threshold: 100 },
      clioId: { enabled: true, type: 'blocking', threshold: 100 },
      phone: { enabled: true, type: 'normalized', threshold: 100 },
      email: { enabled: true, type: 'exact', threshold: 100 },
      dob: { enabled: true, type: 'exact', threshold: 100 },
      address: { enabled: false, type: 'fuzzy', threshold: 80 },
      city: { enabled: false, type: 'exact', threshold: 100 },
      state: { enabled: false, type: 'exact', threshold: 100 },
      country: { enabled: false, type: 'exact', threshold: 100 },
    },
    minConfidenceForMatch: 70,
  },
  aggressive: {
    id: 'aggressive',
    name: 'Aggressive',
    description: 'More matches - lower thresholds, may need more review',
    config: {
      name: { enabled: true, type: 'fuzzy', threshold: 70 },
      ppid: { enabled: true, type: 'exact', threshold: 100 },
      aNumber: { enabled: true, type: 'exact', threshold: 100 },
      clioId: { enabled: true, type: 'blocking', threshold: 100 },
      phone: { enabled: true, type: 'fuzzy', threshold: 90 },
      email: { enabled: true, type: 'fuzzy', threshold: 90 },
      dob: { enabled: true, type: 'exact', threshold: 100 },
      address: { enabled: true, type: 'fuzzy', threshold: 70 },
      city: { enabled: true, type: 'fuzzy', threshold: 85 },
      state: { enabled: false, type: 'exact', threshold: 100 },
      country: { enabled: false, type: 'exact', threshold: 100 },
    },
    minConfidenceForMatch: 60,
  },
};

// Build default config from field definitions
const buildDefaultMatchConfig = () => {
  const config = {};
  Object.values(MATCH_FIELD_DEFINITIONS).forEach(field => {
    config[field.id] = {
      enabled: field.defaultEnabled,
      type: field.defaultType,
      threshold: field.defaultThreshold,
    };
  });
  return config;
};

const DEFAULT_MATCH_CONFIG = {
  preset: 'balanced',
  fields: buildDefaultMatchConfig(),
  minConfidenceForMatch: 70,
};

// Nickname mappings for name matching
const NICKNAMES = {
  'robert': ['bob', 'bobby', 'rob'], 'bob': ['robert'],
  'william': ['bill', 'billy', 'will', 'liam'], 'bill': ['william'],
  'richard': ['rick', 'ricky', 'dick'], 'rick': ['richard'],
  'james': ['jim', 'jimmy', 'jamie'], 'jim': ['james'],
  'michael': ['mike', 'mikey'], 'mike': ['michael'],
  'elizabeth': ['liz', 'beth', 'betty', 'lisa'], 'liz': ['elizabeth'],
  'jennifer': ['jen', 'jenny'], 'jen': ['jennifer'],
  'joseph': ['joe', 'joey'], 'joe': ['joseph'],
  'daniel': ['dan', 'danny'], 'dan': ['daniel'],
  'jose': ['pepe', 'joe'], 'francisco': ['paco', 'frank'],
  'guadalupe': ['lupe', 'lupita'], 'miguel': ['mike'],
  'guillermo': ['memo', 'william'], 'roberto': ['robert', 'beto'],
  'eduardo': ['eddie', 'lalo'], 'alejandro': ['alex'],
};

// ============================================
// UTILITY FUNCTIONS
// ============================================

const hashPassword = async (password) => {
  const encoder = new TextEncoder();
  const data = encoder.encode(password);
  const hashBuffer = await crypto.subtle.digest('SHA-256', data);
  return Array.from(new Uint8Array(hashBuffer)).map(b => b.toString(16).padStart(2, '0')).join('');
};

const removeAccents = (str) => str ? str.normalize('NFD').replace(/[\u0300-\u036f]/g, '') : '';

const normalizeName = (name) => {
  if (!name) return '';
  return removeAccents(name).toLowerCase().trim()
    .replace(/\s*,\s*/g, ' ')
    .replace(/[.,\-'"()]/g, '')
    .replace(/\s+/g, ' ')
    .replace(/\b(jr|sr|ii|iii|iv|dr|mr|mrs|ms)\b\.?/gi, '')
    .trim();
};

const normalizePhone = (phone) => phone ? phone.replace(/\D/g, '').slice(-10) : '';

// ============================================
// MATTER_FLATPACK HELPERS (for Case Master View)
// ============================================

// Parse Matter_Flatpack JSON field into an object
const parseFlatpack = (record, flatpackFieldName = 'Matter_Flatpack') => {
  const flatpackData = record?.fields?.[flatpackFieldName];
  const expanded = { _flatpackKeys: new Set(), _rawEntries: [] };

  if (!flatpackData) return expanded;

  try {
    const parsed = typeof flatpackData === 'string'
      ? JSON.parse(flatpackData)
      : flatpackData;

    // Handle array of entries (append stream)
    if (Array.isArray(parsed)) {
      expanded._rawEntries = parsed;
      // Get latest non-merge entry values
      const latestValues = {};
      for (const entry of parsed) {
        if (entry._dedupe_event) continue; // Skip merge events for display
        for (const [key, value] of Object.entries(entry)) {
          if (!key.startsWith('_')) {
            latestValues[key] = value;
            expanded._flatpackKeys.add(key);
          }
        }
      }
      Object.assign(expanded, latestValues);
    } else if (typeof parsed === 'object') {
      // Single object
      for (const [key, value] of Object.entries(parsed)) {
        if (!key.startsWith('_')) {
          expanded[key] = value;
          expanded._flatpackKeys.add(key);
        }
      }
    }
  } catch (e) {
    console.warn('Failed to parse flatpack:', e);
  }

  return expanded;
};

// Get expanded fields for a record (regular fields + flatpack fields)
const getExpandedFields = (record, tableConfig) => {
  const base = { ...record.fields };
  const flatpackFieldName = tableConfig?.flatpackField;

  if (!flatpackFieldName) {
    return { fields: base, flatpackKeys: new Set() };
  }

  const flatpack = parseFlatpack(record, flatpackFieldName);
  const flatpackKeys = flatpack._flatpackKeys;
  delete flatpack._flatpackKeys;
  delete flatpack._rawEntries;

  // Add flatpack fields with prefix indicator
  for (const [key, value] of Object.entries(flatpack)) {
    base[`â¬¡ ${key}`] = value;
  }

  return { fields: base, flatpackKeys };
};

// Get merge history from Matter_Flatpack
const getMergeHistoryFromFlatpack = (record, flatpackFieldName = 'Matter_Flatpack') => {
  const flatpack = parseFlatpack(record, flatpackFieldName);
  const rawEntries = flatpack._rawEntries || [];
  return rawEntries.filter(entry => entry._dedupe_event);
};

// Check if a record has matterId (Bahr client in Case Master View)
const hasMatterId = (record, tableConfig) => {
  if (!tableConfig?.flatpackField) return false;
  const flatpack = parseFlatpack(record, tableConfig.flatpackField);
  return !!flatpack.matterId;
};

// Get matterId from flatpack
const getMatterId = (record, tableConfig) => {
  if (!tableConfig?.flatpackField) return null;
  const flatpack = parseFlatpack(record, tableConfig.flatpackField);
  return flatpack.matterId || null;
};

// Build merge event for flatpack append stream
const buildFlatpackMergeEvent = (survivor, merged, fieldDecisions, confidence, reasons) => {
  return {
    _dedupe_event: 'merge',
    _merge_id: `mrg_${Date.now().toString(36)}`,
    _timestamp: new Date().toISOString(),
    _confidence: confidence,
    _match_reasons: reasons,
    _survivor_record_id: survivor.id,
    _merged_record: {
      record_id: merged.id,
      fields_snapshot: { ...merged.fields },
    },
    _field_decisions: fieldDecisions,
  };
};

// Append to flatpack array without losing data
const appendToFlatpack = (existingFlatpack, newEntry) => {
  let entries = [];
  try {
    if (existingFlatpack) {
      const parsed = typeof existingFlatpack === 'string'
        ? JSON.parse(existingFlatpack)
        : existingFlatpack;
      entries = Array.isArray(parsed) ? parsed : [parsed];
    }
  } catch (e) {
    console.warn('Failed to parse existing flatpack:', e);
  }

  entries.push(newEntry);
  return JSON.stringify(entries, null, 2);
};

const levenshteinDistance = (a, b) => {
  if (!a || !b) return Math.max((a||'').length, (b||'').length);
  const matrix = Array(b.length + 1).fill(null).map(() => Array(a.length + 1).fill(null));
  for (let i = 0; i <= a.length; i++) matrix[0][i] = i;
  for (let j = 0; j <= b.length; j++) matrix[j][0] = j;
  for (let j = 1; j <= b.length; j++) {
    for (let i = 1; i <= a.length; i++) {
      const cost = a[i-1] === b[j-1] ? 0 : 1;
      matrix[j][i] = Math.min(matrix[j][i-1] + 1, matrix[j-1][i] + 1, matrix[j-1][i-1] + cost);
    }
  }
  return matrix[b.length][a.length];
};

const stringSimilarity = (a, b) => {
  if (!a && !b) return 100;
  if (!a || !b) return 0;
  const dist = levenshteinDistance(a.toLowerCase(), b.toLowerCase());
  return Math.round((1 - dist / Math.max(a.length, b.length)) * 100);
};

const areNamesRelated = (name1, name2, threshold = 85) => {
  const n1 = normalizeName(name1);
  const n2 = normalizeName(name2);
  if (n1 === n2) return { match: true, score: 100, reason: 'exact' };

  const parts1 = n1.split(' ').filter(Boolean);
  const parts2 = n2.split(' ').filter(Boolean);

  // Check nickname matches
  for (const p1 of parts1) {
    for (const p2 of parts2) {
      if (p1 === p2) continue;
      const nicks1 = NICKNAMES[p1] || [];
      const nicks2 = NICKNAMES[p2] || [];
      if (nicks1.includes(p2) || nicks2.includes(p1)) {
        return { match: true, score: 95, reason: 'nickname' };
      }
    }
  }

  // Fuzzy match - use configurable threshold
  const sim = stringSimilarity(n1, n2);
  if (sim >= threshold) return { match: true, score: sim, reason: 'fuzzy' };

  // Shared parts - lower the bar if threshold is lower
  const minSharedParts = threshold >= 85 ? 2 : 1;
  const shared = parts1.filter(p => parts2.includes(p));
  if (shared.length >= minSharedParts && shared.length >= 2) {
    return { match: true, score: Math.max(80, sim), reason: 'shared_parts' };
  }

  return { match: false, score: sim, reason: 'no_match' };
};

const generateMergeId = () => 'mrg_' + Math.random().toString(36).substr(2, 9);

// ============================================
// AUTO-CONFLICT RESOLUTION RULES
// ============================================

// Normalize phone for comparison (returns 10-digit number)
const normalizePhoneForComparison = (phone) => {
  if (!phone) return '';
  // Remove all non-digits, then take last 10 digits
  const digits = phone.replace(/\D/g, '');
  return digits.slice(-10);
};

// Check if two phone numbers are the same (normalized)
const phonesMatch = (phoneA, phoneB) => {
  const normA = normalizePhoneForComparison(phoneA);
  const normB = normalizePhoneForComparison(phoneB);
  return normA.length >= 10 && normA === normB;
};

// Prefer the more formatted phone number
const preferFormattedPhone = (phoneA, phoneB) => {
  // If they're the same normalized, prefer the one with more formatting or starts with +1
  if (phoneB && phoneB.startsWith('+1')) return 'B';
  if (phoneA && phoneA.startsWith('+1')) return 'A';
  // Prefer the one with dashes or spaces (formatted)
  const formatA = (phoneA || '').includes('-') || (phoneA || '').includes(' ');
  const formatB = (phoneB || '').includes('-') || (phoneB || '').includes(' ');
  if (formatB && !formatA) return 'B';
  return 'A'; // Default to survivor
};

// Auto-resolve field conflicts based on smart rules
const autoResolveConflict = (fieldName, valA, valB, survivorFields, mergedFields) => {
  const isEmpty = (v) => v === null || v === undefined || (typeof v === 'string' && !v.trim()) || (Array.isArray(v) && v.length === 0);

  // If one is empty, use the other
  if (isEmpty(valA) && !isEmpty(valB)) return { strategy: 'keep_b', value: valB };
  if (!isEmpty(valA) && isEmpty(valB)) return { strategy: 'keep_a', value: valA };
  if (isEmpty(valA) && isEmpty(valB)) return { strategy: 'keep_a', value: valA };

  // Phone Number: Normalize and compare
  if (fieldName === 'Phone Number') {
    if (phonesMatch(valA, valB)) {
      const pick = preferFormattedPhone(valA, valB);
      return { strategy: pick === 'A' ? 'keep_a' : 'keep_b', value: pick === 'A' ? valA : valB, reason: 'Same phone (normalized)' };
    }
    // Different phones - prefer survivor's (more established record)
    return { strategy: 'keep_a', value: valA, reason: 'Different phones - keeping survivor' };
  }

  // Box folder fields: Keep survivor's, track merged one for deletion
  if (['Box_Folder_ID', 'URL to box folder (not shared)', 'box folder name', 'box share 2.0', 'box_shared_link'].includes(fieldName)) {
    return { strategy: 'keep_a', value: valA, reason: 'Keeping survivor box folder', deleteFromMerged: valB };
  }

  // PPID fields: Keep survivor's (primary record identifier)
  if (fieldName === 'PPID' || fieldName === 'PPID copy') {
    // Prefer non-empty, then survivor
    return { strategy: 'keep_a', value: valA, reason: 'PPID conflict - keeping survivor' };
  }

  // clio_contact_id: Keep survivor's
  if (fieldName === 'clio_contact_id') {
    return { strategy: 'keep_a', value: valA, reason: 'Clio ID conflict - keeping survivor' };
  }

  // smsFolder: Keep survivor's
  if (fieldName === 'smsFolder') {
    return { strategy: 'keep_a', value: valA, reason: 'SMS folder conflict - keeping survivor' };
  }

  // DOB: Keep survivor's if both have values
  if (fieldName === 'DOB') {
    return { strategy: 'keep_a', value: valA, reason: 'DOB conflict - keeping survivor' };
  }

  // Middle Name: Keep survivor's (often just data entry variations)
  if (fieldName === 'Middle Name') {
    return { strategy: 'keep_a', value: valA, reason: 'Middle name conflict - keeping survivor' };
  }

  // Xano Last Updated: Keep more recent timestamp
  if (fieldName === 'Xano Last Updated') {
    if (valA && valB) {
      const dateA = new Date(valA);
      const dateB = new Date(valB);
      if (dateB > dateA) return { strategy: 'keep_b', value: valB, reason: 'More recent timestamp' };
    }
    return { strategy: 'keep_a', value: valA, reason: 'Timestamp conflict' };
  }

  // State: Merge arrays, or keep survivor for single values
  if (fieldName === 'State') {
    if (Array.isArray(valA) && Array.isArray(valB)) {
      const merged = [...new Set([...valA, ...valB])];
      return { strategy: 'merge', value: merged, reason: 'Merged state arrays' };
    }
    return { strategy: 'keep_a', value: valA, reason: 'State conflict - keeping survivor' };
  }

  // Zip codes: Keep survivor's
  if (fieldName === 'Zip (5)' || fieldName.includes('Zip')) {
    return { strategy: 'keep_a', value: valA, reason: 'Zip conflict - keeping survivor' };
  }

  // bahr_import_flatpack_data: Keep survivor's (likely contains more complete data)
  if (fieldName === 'bahr_import_flatpack_data') {
    return { strategy: 'keep_a', value: valA, reason: 'Keeping survivor import data' };
  }

  // box_sync: Keep 'Yes' if either has it
  if (fieldName === 'box sync') {
    if (valA === 'Yes' || valA === true) return { strategy: 'keep_a', value: valA, reason: 'Box sync enabled' };
    if (valB === 'Yes' || valB === true) return { strategy: 'keep_b', value: valB, reason: 'Box sync enabled' };
    return { strategy: 'keep_a', value: valA };
  }

  // Email fields: Prefer non-null@blank emails
  if (fieldName === 'Client Email' || fieldName.includes('Email')) {
    const aIsBlank = (valA || '').includes('null@blank');
    const bIsBlank = (valB || '').includes('null@blank');
    if (aIsBlank && !bIsBlank) return { strategy: 'keep_b', value: valB, reason: 'Valid email' };
    if (!aIsBlank && bIsBlank) return { strategy: 'keep_a', value: valA, reason: 'Valid email' };
    return { strategy: 'keep_a', value: valA, reason: 'Email conflict - keeping survivor' };
  }

  // A# (Alien number): Keep survivor's - this is a critical identifier
  if (fieldName === 'A#') {
    return { strategy: 'keep_a', value: valA, reason: 'A# conflict - keeping survivor' };
  }

  // Default: Keep survivor's value (survivor already has highest quality score)
  // The merge history stores ALL data from merged record, so nothing is lost
  return { strategy: 'keep_a', value: valA, reason: 'Keeping survivor value (merged data preserved in history)' };
};

// Calculate completeness score for a record's fields
const getRecordCompleteness = (fields) => {
  if (!fields) return 0;
  let score = 0;
  const importantFields = ['First Name', 'Family Name', 'DOB', 'Phone Number', 'Client Email', 'A#', 'PPID', 'Address Line 1', 'City', 'State', 'Country'];

  importantFields.forEach(field => {
    const val = fields[field];
    if (val && (typeof val !== 'string' || val.trim())) {
      score += 10;
    }
  });

  // Also count total non-empty fields
  Object.values(fields).forEach(val => {
    if (val !== null && val !== undefined) {
      if (Array.isArray(val) && val.length > 0) score += 1;
      else if (typeof val === 'string' && val.trim()) score += 1;
      else if (typeof val === 'number' || typeof val === 'boolean') score += 1;
    }
  });

  return score;
};

// Default webhook URL for Box folder migration (production - no "test" in URL)
const DEFAULT_BOX_MIGRATION_WEBHOOK = 'https://n8n.intelechia.com/webhook/box-dedup';

// Get all box folder-related fields that would be deleted
const getBoxFolderDeletions = (fieldDecisions, mergedFields) => {
  const boxFolderFields = ['Box_Folder_ID', 'URL to box folder (not shared)', 'box folder name', 'box share 2.0', 'box_shared_link'];
  const deletions = {};

  boxFolderFields.forEach(fieldName => {
    const decision = fieldDecisions[fieldName];
    if (decision && decision.deleteFromMerged) {
      deletions[fieldName] = decision.deleteFromMerged;
    } else if (mergedFields[fieldName] && fieldDecisions[fieldName]?.strategy !== 'keep_b') {
      // Track any box folder values from merged record that won't be kept
      deletions[fieldName] = mergedFields[fieldName];
    }
  });

  return Object.keys(deletions).length > 0 ? deletions : null;
};

// Check if Box folders need migration (both records have different Box folder IDs)
const getBoxMigrationInfo = (survivorFields, mergedFields) => {
  const survivorBoxId = survivorFields['Box_Folder_ID'];
  const mergedBoxId = mergedFields['Box_Folder_ID'];

  // If both have Box folder IDs and they're different, migration is needed
  if (survivorBoxId && mergedBoxId && survivorBoxId !== mergedBoxId) {
    return {
      needsMigration: true,
      keepBoxFolderId: survivorBoxId,
      deleteBoxFolderId: mergedBoxId,
      keepBoxUrl: survivorFields['URL to box folder (not shared)'] || survivorFields['box_shared_link'] || '',
      deleteBoxUrl: mergedFields['URL to box folder (not shared)'] || mergedFields['box_shared_link'] || '',
      keepBoxName: survivorFields['box folder name'] || '',
      deleteBoxName: mergedFields['box folder name'] || ''
    };
  }

  // If only merged has box folder, we should migrate it to survivor
  if (!survivorBoxId && mergedBoxId) {
    return {
      needsMigration: false, // No migration needed, we'll just keep merged's folder
      adoptFolder: true,
      adoptBoxFolderId: mergedBoxId,
      adoptBoxUrl: mergedFields['URL to box folder (not shared)'] || mergedFields['box_shared_link'] || '',
      adoptBoxName: mergedFields['box folder name'] || ''
    };
  }

  return { needsMigration: false };
};

// Send webhook to n8n for Box folder migration
// n8n expects: { target_folder_id, duplicate_folder_ids[], airtable_record_id }
const sendBoxMigrationWebhook = async (webhookUrl, migrationData) => {
  const url = webhookUrl || DEFAULT_BOX_MIGRATION_WEBHOOK;

  // Transform to n8n expected format:
  // - target_folder_id = folder to KEEP (survivor's Box folder)
  // - duplicate_folder_ids = folders to merge FROM (merged record's Box folder)
  // - airtable_record_id = survivor record ID to update status
  const n8nPayload = {
    target_folder_id: migrationData.keepBoxFolderId,
    duplicate_folder_ids: [migrationData.deleteBoxFolderId],
    airtable_record_id: migrationData.survivorRecordId,
    // Include metadata for tracking/debugging
    metadata: {
      action: 'box_folder_migration',
      timestamp: new Date().toISOString(),
      survivor_record_name: migrationData.survivorRecordName,
      merged_record_id: migrationData.mergedRecordId,
      merged_record_name: migrationData.mergedRecordName,
      keep_folder_url: migrationData.keepBoxUrl,
      delete_folder_url: migrationData.deleteBoxUrl,
      keep_folder_name: migrationData.keepBoxName,
      delete_folder_name: migrationData.deleteBoxName
    }
  };

  try {
    const response = await fetch(url, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(n8nPayload)
    });

    if (!response.ok) {
      throw new Error(`Webhook failed: ${response.status}`);
    }

    const result = await response.json().catch(() => ({}));
    return { success: true, result, payload: n8nPayload };
  } catch (error) {
    console.error('Box migration webhook error:', error);
    return { success: false, error: error.message, payload: n8nPayload };
  }
};

// ============================================
// AIRTABLE CLIENT
// ============================================

class AirtableClient {
  constructor(apiKey, baseId) {
    this.apiKey = apiKey;
    this.baseId = baseId;
    this.baseUrl = `https://api.airtable.com/v0/${baseId}`;
    this.metaUrl = `https://api.airtable.com/v0/meta/bases/${baseId}/tables`;
  }

  async request(url, options = {}) {
    const response = await fetch(url, {
      ...options,
      headers: { 'Authorization': `Bearer ${this.apiKey}`, 'Content-Type': 'application/json', ...options.headers },
    });
    if (!response.ok) {
      const error = await response.json().catch(() => ({}));
      throw new Error(error.error?.message || `API error: ${response.status}`);
    }
    return response.json();
  }

  async getTableSchema(tableName) {
    const result = await this.request(this.metaUrl);
    const table = result.tables.find(t => t.name === tableName);
    if (!table) throw new Error(`Table "${tableName}" not found`);

    const computedTypes = ['formula', 'rollup', 'count', 'lookup', 'multipleLookupValues', 'autoNumber', 'createdTime', 'lastModifiedTime', 'createdBy', 'lastModifiedBy', 'button'];
    const schema = { writableFields: [], computedFields: [], linkFields: [], textFields: [] };

    table.fields.forEach(field => {
      const isComputed = computedTypes.includes(field.type) || field.name.includes('(from');
      if (isComputed) {
        schema.computedFields.push(field.name);
      } else {
        schema.writableFields.push(field.name);
        if (field.type === 'multipleRecordLinks') schema.linkFields.push(field.name);
        else schema.textFields.push(field.name);
      }
    });
    return schema;
  }

  async getAllRecords(tableName, fields = [], filterFormula = '', onProgress = null) {
    const allRecords = [];
    let offset = null, page = 0;
    do {
      const params = new URLSearchParams();
      fields.forEach(f => params.append('fields[]', f));
      if (filterFormula) params.append('filterByFormula', filterFormula);
      if (offset) params.append('offset', offset);
      params.append('pageSize', '100');

      const result = await this.request(`${this.baseUrl}/${encodeURIComponent(tableName)}?${params}`);
      const newRecords = result.records;
      allRecords.push(...newRecords);
      offset = result.offset;
      page++;
      // Pass the new batch of records for streaming support
      if (onProgress) onProgress({ page, total: allRecords.length, hasMore: !!offset, records: newRecords });
      if (offset) await new Promise(r => setTimeout(r, 200));
    } while (offset);
    return allRecords;
  }

  async updateRecord(tableName, recordId, fields) {
    return this.request(`${this.baseUrl}/${encodeURIComponent(tableName)}/${recordId}`, {
      method: 'PATCH', body: JSON.stringify({ fields }),
    });
  }

  async getRecord(tableName, recordId) {
    return this.request(`${this.baseUrl}/${encodeURIComponent(tableName)}/${recordId}`);
  }

  async createRecord(tableName, fields) {
    return this.request(`${this.baseUrl}/${encodeURIComponent(tableName)}`, {
      method: 'POST', body: JSON.stringify({ fields }),
    });
  }

  async deleteRecord(tableName, recordId) {
    return this.request(`${this.baseUrl}/${encodeURIComponent(tableName)}/${recordId}`, { method: 'DELETE' });
  }
}

// ============================================
// MATCHING ENGINE
// ============================================

const scoreRecordQuality = (record) => {
  const f = record.fields || {};
  let score = 0;
  if (f['A#']?.trim()) score += 50;
  if (f['DOB']) score += 30;
  if (f['clio_contact_id']) score += 25;
  if (f['PPID']) score += 20;
  if (f['Box_Folder_ID']) score += 40;
  if (f['Phone Number']?.trim()) score += 15;
  if (f['Client Email']?.trim() && !f['Client Email'].includes('null@blank')) score += 15;
  if (f['Address Line 1'] || f['Address']) score += 10;
  score += (f['Case Master View'] || []).length * 100;
  score += (f['Events'] || []).length * 50;
  score += (f['Relationships'] || []).length * 30;
  score += (f['Matters'] || []).length * 80;
  score += (f['Client Notes'] || []).length * 20;
  if (f['First Name']) score += 5;
  if (f['Family Name']) score += 5;
  return score;
};

const getDisplayName = (record) => {
  const f = record.fields || {};
  return f['Full_Name_Normal_Pretty'] || f['Client Name'] ||
    [f['First Name'], f['Middle Name'], f['Family Name']].filter(Boolean).join(' ') || record.id;
};

// Helper function to compare field values based on match type and threshold
const compareFieldValues = (valA, valB, matchType, threshold) => {
  if (!valA || !valB) return { match: false, score: 0 };

  const strA = String(valA).trim().toLowerCase();
  const strB = String(valB).trim().toLowerCase();

  if (!strA || !strB) return { match: false, score: 0 };

  if (matchType === 'exact') {
    const isMatch = strA === strB;
    return { match: isMatch, score: isMatch ? 100 : 0 };
  }

  if (matchType === 'normalized') {
    // For phones, normalize to 10 digits
    const normA = strA.replace(/\D/g, '').slice(-10);
    const normB = strB.replace(/\D/g, '').slice(-10);
    if (normA.length >= 10 && normA === normB) {
      return { match: true, score: 100 };
    }
    // Fuzzy fallback if configured
    const sim = stringSimilarity(normA, normB);
    return { match: sim >= threshold, score: sim };
  }

  if (matchType === 'fuzzy') {
    const sim = stringSimilarity(strA, strB);
    return { match: sim >= threshold, score: sim };
  }

  return { match: false, score: 0 };
};

const scoreMatch = (recordA, recordB, matchConfig = DEFAULT_MATCH_CONFIG) => {
  const fa = recordA.fields || {}, fb = recordB.fields || {};
  const reasons = [], conflicts = [];
  let confidence = 0;
  let hasIdMatch = false;
  const fieldConfig = matchConfig.fields || {};

  // Handle blocking fields first (like clio_contact_id)
  const clioConfig = fieldConfig.clioId || { enabled: true, type: 'blocking' };
  if (clioConfig.enabled) {
    const clioA = fa['clio_contact_id'], clioB = fb['clio_contact_id'];
    if (clioA && clioB && clioA !== clioB) {
      return null; // Definitively not a match
    }
    if (clioA && clioB && clioA === clioB) {
      reasons.push('clio_contact_id exact');
      hasIdMatch = true;
    }
  }

  // Check for ID conflicts/matches
  const ppidConfig = fieldConfig.ppid || { enabled: true, type: 'exact' };
  const aNumConfig = fieldConfig.aNumber || { enabled: true, type: 'exact' };

  const checkIdField = (airtableField, configKey, config) => {
    if (!config.enabled) return;
    const valA = fa[airtableField], valB = fb[airtableField];
    if (valA && valB) {
      if (valA === valB) {
        reasons.push(`${airtableField} exact`);
        hasIdMatch = true;
      } else {
        conflicts.push(`${airtableField}: "${valA}" vs "${valB}"`);
      }
    }
  };

  checkIdField('PPID', 'ppid', ppidConfig);
  checkIdField('A#', 'aNumber', aNumConfig);

  // Return Tier 4 (Conflicts) if there are ID conflicts
  if (conflicts.length > 0) {
    return { tier: MATCH_TIERS.TIER4, confidence: 50, reasons, conflicts, isConflict: true };
  }

  // Name matching
  const nameConfig = fieldConfig.name || { enabled: true, type: 'fuzzy', threshold: 85 };
  if (nameConfig.enabled) {
    const nameA = [fa['First Name'], fa['Family Name']].filter(Boolean).join(' ') || fa['Client Name'];
    const nameB = [fb['First Name'], fb['Family Name']].filter(Boolean).join(' ') || fb['Client Name'];
    if (nameA && nameB) {
      const threshold = nameConfig.threshold || 85;
      const nameMatch = areNamesRelated(nameA, nameB, threshold);
      if (nameMatch.match) {
        reasons.push(`Name ${nameMatch.score}% (${nameMatch.reason})`);
        confidence = nameMatch.score;

        // Exact full name match is Tier 1 (Definitive)
        if (nameMatch.score === 100 && nameMatch.reason === 'exact') {
          return { tier: MATCH_TIERS.TIER1, confidence: 100, reasons, conflicts, isConflict: false };
        }
      }
    }
  }

  // ID match boosts confidence
  if (hasIdMatch) {
    confidence = Math.max(confidence, 90);
  }

  // Corroborating fields boost confidence
  let corroboration = 0;

  // Phone matching
  const phoneConfig = fieldConfig.phone || { enabled: true, type: 'normalized', threshold: 100 };
  if (phoneConfig.enabled) {
    const phoneResult = compareFieldValues(
      fa['Phone Number'],
      fb['Phone Number'],
      phoneConfig.type,
      phoneConfig.threshold
    );
    if (phoneResult.match) {
      reasons.push(`Phone ${phoneResult.score}%`);
      corroboration++;
      confidence = Math.min(100, confidence + 10);
    }
  }

  // DOB matching
  const dobConfig = fieldConfig.dob || { enabled: true, type: 'exact' };
  if (dobConfig.enabled && fa['DOB'] && fb['DOB'] && fa['DOB'] === fb['DOB']) {
    reasons.push('DOB exact');
    corroboration++;
    confidence = Math.min(100, confidence + 15);
  }

  // Email matching
  const emailConfig = fieldConfig.email || { enabled: true, type: 'exact', threshold: 100 };
  if (emailConfig.enabled) {
    const emailA = (fa['Client Email'] || '').toLowerCase();
    const emailB = (fb['Client Email'] || '').toLowerCase();
    if (emailA && emailB && !emailA.includes('null@blank') && !emailB.includes('null@blank')) {
      const emailResult = compareFieldValues(emailA, emailB, emailConfig.type, emailConfig.threshold);
      if (emailResult.match) {
        reasons.push(`Email ${emailResult.score}%`);
        corroboration++;
        confidence = Math.min(100, confidence + 10);
      }
    }
  }

  // Additional standard fields (address, city, state, country)
  const additionalFields = [
    { configKey: 'address', airtableFields: ['Address Line 1', 'Address'], label: 'Address', boost: 5 },
    { configKey: 'city', airtableFields: ['City'], label: 'City', boost: 5 },
    { configKey: 'state', airtableFields: ['State'], label: 'State', boost: 3 },
    { configKey: 'country', airtableFields: ['Country'], label: 'Country', boost: 3 },
  ];

  additionalFields.forEach(({ configKey, airtableFields, label, boost }) => {
    const config = fieldConfig[configKey];
    if (!config || !config.enabled) return;

    let valA, valB;
    for (const fieldName of airtableFields) {
      if (!valA && fa[fieldName]) valA = fa[fieldName];
      if (!valB && fb[fieldName]) valB = fb[fieldName];
    }

    if (valA && valB) {
      const result = compareFieldValues(valA, valB, config.type, config.threshold);
      if (result.match) {
        reasons.push(`${label} ${result.score}%`);
        corroboration++;
        confidence = Math.min(100, confidence + boost);
      }
    }
  });

  // Custom fields (both regular and JSON-derived)
  Object.entries(fieldConfig).forEach(([configKey, config]) => {
    if (!config.isCustom || !config.enabled) return;

    let valA, valB;

    if (config.isJsonField && config.jsonKey) {
      // JSON field - extract value from bahr_import_flatpack_data
      const sourceField = config.sourceField || 'bahr_import_flatpack_data';
      try {
        const jsonA = fa[sourceField];
        const jsonB = fb[sourceField];
        const parsedA = jsonA ? (typeof jsonA === 'string' ? JSON.parse(jsonA) : jsonA) : null;
        const parsedB = jsonB ? (typeof jsonB === 'string' ? JSON.parse(jsonB) : jsonB) : null;
        valA = parsedA?.[config.jsonKey];
        valB = parsedB?.[config.jsonKey];
      } catch (e) {
        // Skip if JSON parsing fails
        return;
      }
    } else if (config.airtableField) {
      // Regular custom field
      valA = fa[config.airtableField];
      valB = fb[config.airtableField];
    } else {
      return;
    }

    if (valA && valB) {
      const result = compareFieldValues(valA, valB, config.type, config.threshold);
      if (result.match) {
        const label = config.isJsonField ? `JSON:${config.jsonKey}` : (config.label || config.airtableField);
        reasons.push(`${label} ${result.score}%`);
        corroboration++;
        confidence = Math.min(100, confidence + 5);
      }
    }
  });

  // Use configurable minimum confidence
  const minConfidence = matchConfig.minConfidenceForMatch || 70;

  // Determine tier based on confidence and corroboration
  let tier;
  if (hasIdMatch || confidence >= 85 || (confidence >= 75 && corroboration >= 1)) {
    tier = MATCH_TIERS.TIER2;
  } else if (confidence >= minConfidence) {
    tier = MATCH_TIERS.TIER3;
  } else {
    // Below minimum confidence threshold
    return null;
  }

  return { tier, confidence: Math.round(Math.max(confidence, minConfidence)), reasons, conflicts, isConflict: false };
};

const findDuplicateCandidates = (records, onProgress, matchConfig = DEFAULT_MATCH_CONFIG) => {
  const candidates = [];
  const processed = new Set();
  const minConfidence = matchConfig.minConfidenceForMatch || 70;

  // Group by normalized name for efficiency
  const groups = new Map();
  records.forEach((record, idx) => {
    const f = record.fields || {};
    const key = normalizeName([f['First Name'], f['Family Name']].filter(Boolean).join(' ') || f['Client Name'] || '');
    if (!key) return;
    if (!groups.has(key)) groups.set(key, []);
    groups.get(key).push({ record, idx });
  });

  let groupNum = 0;
  groups.forEach((group, key) => {
    groupNum++;
    if (group.length < 2) return;

    for (let i = 0; i < group.length; i++) {
      for (let j = i + 1; j < group.length; j++) {
        const pairKey = [group[i].record.id, group[j].record.id].sort().join('|');
        if (processed.has(pairKey)) continue;
        processed.add(pairKey);

        const match = scoreMatch(group[i].record, group[j].record, matchConfig);
        if (match && (match.confidence >= minConfidence || match.isConflict)) {
          const scoreA = scoreRecordQuality(group[i].record);
          const scoreB = scoreRecordQuality(group[j].record);
          const [survivor, merged] = scoreA >= scoreB ? [group[i], group[j]] : [group[j], group[i]];

          candidates.push({
            id: `match_${candidates.length}`,
            ...match,
            survivor: { record: survivor.record, score: Math.max(scoreA, scoreB), name: getDisplayName(survivor.record) },
            merged: { record: merged.record, score: Math.min(scoreA, scoreB), name: getDisplayName(merged.record) },
          });
        }
      }
    }
    if (onProgress && groupNum % 50 === 0) onProgress({ phase: 'matching', current: groupNum, total: groups.size });
  });

  candidates.sort((a, b) => a.tier.tier - b.tier.tier || b.confidence - a.confidence);
  return candidates;
};

// ============================================
// HISTORY FUNCTIONS
// ============================================

const parseDedupeHistory = (historyField, options = {}) => {
  const { throwOnParseError = false } = options;
  if (!historyField) return [];
  try {
    const parsed = JSON.parse(historyField);
    if (Array.isArray(parsed)) return parsed;
    // Non-array data exists - this is an error condition
    if (throwOnParseError) {
      throw new Error('Dedupe history exists but is not an array - cannot safely append');
    }
    console.warn('Dedupe history is not an array, returning empty to preserve data');
    return [];
  } catch (err) {
    // Parse error on existing data - this is dangerous for append-only
    if (throwOnParseError) {
      throw new Error(`Cannot parse existing dedupe history - refusing to overwrite: ${err.message}`);
    }
    console.warn('Failed to parse dedupe history:', err.message);
    return [];
  }
};

// Safely append to dedupe history - ensures we never lose existing entries
const appendToDedupeHistory = (existingHistoryField, newEntry) => {
  // Parse existing history - throw if we can't parse existing data
  const existingHistory = parseDedupeHistory(existingHistoryField, { throwOnParseError: true });
  const previousCount = existingHistory.length;

  // Append the new entry
  existingHistory.push(newEntry);

  // Validate append-only: new length must be exactly previous + 1
  if (existingHistory.length !== previousCount + 1) {
    throw new Error(`Append-only violation: expected ${previousCount + 1} entries, got ${existingHistory.length}`);
  }

  return JSON.stringify(existingHistory, null, 2);
};

// Safely update dedupe history - ensures we never lose existing entries
// Used for operations that modify existing entries (like adding unmerge info)
const updateDedupeHistorySafely = (existingHistoryField, updateFn) => {
  // Parse existing history - throw if we can't parse existing data
  const existingHistory = parseDedupeHistory(existingHistoryField, { throwOnParseError: true });
  const previousCount = existingHistory.length;

  // Apply the update function
  const updatedHistory = updateFn([...existingHistory]);

  // Validate append-only: we should never have fewer entries
  if (updatedHistory.length < previousCount) {
    throw new Error(`Append-only violation: history shrank from ${previousCount} to ${updatedHistory.length} entries`);
  }

  return JSON.stringify(updatedHistory, null, 2);
};

const buildMergeHistoryEntry = (survivor, merged, fieldDecisions, matchInfo, notes = '', boxMigration = null) => {
  const entry = {
    merge_id: generateMergeId(),
    timestamp: new Date().toISOString(),
    action: 'merge',
    confidence: matchInfo.confidence,
    match_reasons: matchInfo.reasons,
    survivor_record_id: survivor.record.id,
    merged_records: [{
      original_record_id: merged.record.id,
      field_snapshot: { ...merged.record.fields },
    }],
    field_decisions: fieldDecisions,
    performed_by: 'user',
    notes,
  };

  // Add box migration info if applicable
  if (boxMigration) {
    entry.box_migration = {
      required: true,
      keep_folder_id: boxMigration.keepBoxFolderId,
      delete_folder_id: boxMigration.deleteBoxFolderId,
      keep_folder_url: boxMigration.keepBoxUrl,
      delete_folder_url: boxMigration.deleteBoxUrl,
      webhook_sent: boxMigration.webhookSent,
      webhook_sent_at: boxMigration.webhookSentAt,
      webhook_response: boxMigration.webhookResponse,
      migration_confirmed: boxMigration.migrationConfirmed || false,
      migration_confirmed_at: boxMigration.migrationConfirmedAt || null
    };
  }

  return entry;
};

// ============================================
// MATCH SETTINGS PANEL COMPONENT
// ============================================

function MatchSettingsPanel({ config, onChange, onRescan, allRecords, schema, disabled }) {
  const [expanded, setExpanded] = useState(false);
  const [showAllFields, setShowAllFields] = useState(false);
  const [showAddField, setShowAddField] = useState(false);
  const [showJsonFields, setShowJsonFields] = useState(false);

  // Extract keys from bahr_import_flatpack_data JSON field
  const jsonFieldKeys = useMemo(() => {
    if (!allRecords || allRecords.length === 0) return [];

    const keyCounts = {};
    const sampleValues = {};

    allRecords.forEach(record => {
      const jsonData = record.fields?.['bahr_import_flatpack_data'];
      if (jsonData) {
        try {
          const parsed = typeof jsonData === 'string' ? JSON.parse(jsonData) : jsonData;
          if (parsed && typeof parsed === 'object' && !Array.isArray(parsed)) {
            Object.entries(parsed).forEach(([key, value]) => {
              if (value !== null && value !== undefined && value !== '') {
                keyCounts[key] = (keyCounts[key] || 0) + 1;
                if (!sampleValues[key] && typeof value === 'string') {
                  sampleValues[key] = value.substring(0, 50);
                }
              }
            });
          }
        } catch (e) {
          // Skip invalid JSON
        }
      }
    });

    // Return keys that appear in at least 10 records, sorted by frequency
    return Object.entries(keyCounts)
      .filter(([key, count]) => count >= 10)
      .sort((a, b) => b[1] - a[1])
      .map(([key, count]) => ({
        key,
        count,
        sampleValue: sampleValues[key] || '',
        label: `JSON: ${key}`,
      }));
  }, [allRecords]);

  // Get available fields from schema that can be added as custom match fields
  const availableCustomFields = useMemo(() => {
    if (!schema) return [];
    const existingFieldIds = Object.keys(MATCH_FIELD_DEFINITIONS);
    const customFieldIds = Object.keys(config.fields).filter(id => !MATCH_FIELD_DEFINITIONS[id]);
    const usedIds = [...existingFieldIds, ...customFieldIds];

    // Map of field IDs to their Airtable field names
    const fieldIdToName = {
      name: ['First Name', 'Family Name', 'Client Name'],
      ppid: ['PPID'],
      aNumber: ['A#'],
      clioId: ['clio_contact_id'],
      phone: ['Phone Number'],
      email: ['Client Email'],
      dob: ['DOB'],
      address: ['Address Line 1', 'Address'],
      city: ['City'],
      state: ['State'],
      country: ['Country'],
    };

    // Get all used field identifiers (both Airtable names and JSON keys)
    const usedFieldNames = new Set();
    Object.entries(fieldIdToName).forEach(([id, names]) => {
      if (usedIds.includes(id)) {
        names.forEach(n => usedFieldNames.add(n));
      }
    });
    // Also add custom field names and JSON keys that are already added
    customFieldIds.forEach(id => {
      const customField = config.fields[id];
      if (customField) {
        if (customField.airtableField) usedFieldNames.add(customField.airtableField);
        if (customField.jsonKey) usedFieldNames.add(`json:${customField.jsonKey}`);
      }
    });

    // Filter to writable text-like fields not already used
    return schema.writableFields
      .filter(fieldName => !usedFieldNames.has(fieldName))
      .filter(fieldName => {
        // Exclude obvious non-matchable fields
        const lower = fieldName.toLowerCase();
        return !lower.includes('history') &&
               !lower.includes('notes') &&
               !lower.includes('box') &&
               !lower.includes('sync') &&
               !lower.includes('import') &&
               !lower.includes('legacy');
      })
      .sort();
  }, [schema, config.fields]);

  // Get available JSON keys not already added
  const availableJsonKeys = useMemo(() => {
    const usedJsonKeys = new Set();
    Object.values(config.fields).forEach(fieldConfig => {
      if (fieldConfig.jsonKey) {
        usedJsonKeys.add(fieldConfig.jsonKey);
      }
    });
    return jsonFieldKeys.filter(item => !usedJsonKeys.has(item.key));
  }, [jsonFieldKeys, config.fields]);

  const handlePresetChange = (presetId) => {
    const preset = MATCH_PRESETS[presetId];
    if (preset) {
      // Keep any custom fields that were added
      const customFields = {};
      Object.entries(config.fields).forEach(([id, fieldConfig]) => {
        if (!MATCH_FIELD_DEFINITIONS[id]) {
          customFields[id] = fieldConfig;
        }
      });

      onChange({
        preset: presetId,
        fields: { ...preset.config, ...customFields },
        minConfidenceForMatch: preset.minConfidenceForMatch,
      });
    }
  };

  const handleFieldToggle = (fieldId) => {
    const newFields = { ...config.fields };
    newFields[fieldId] = { ...newFields[fieldId], enabled: !newFields[fieldId].enabled };
    onChange({ ...config, preset: 'custom', fields: newFields });
  };

  const handleFieldTypeChange = (fieldId, type) => {
    const newFields = { ...config.fields };
    newFields[fieldId] = { ...newFields[fieldId], type };
    onChange({ ...config, preset: 'custom', fields: newFields });
  };

  const handleThresholdChange = (fieldId, threshold) => {
    const newFields = { ...config.fields };
    newFields[fieldId] = { ...newFields[fieldId], threshold: parseInt(threshold) };
    onChange({ ...config, preset: 'custom', fields: newFields });
  };

  const handleAddCustomField = (airtableFieldName) => {
    // Generate a unique ID for this custom field
    const fieldId = 'custom_' + airtableFieldName.toLowerCase().replace(/[^a-z0-9]/g, '_');
    const newFields = { ...config.fields };
    newFields[fieldId] = {
      enabled: true,
      type: 'fuzzy',
      threshold: 85,
      airtableField: airtableFieldName,
      isCustom: true,
      label: airtableFieldName,
    };
    onChange({ ...config, preset: 'custom', fields: newFields });
    setShowAddField(false);
  };

  // Handler for adding JSON field keys as match criteria
  const handleAddJsonField = (jsonKey) => {
    const fieldId = 'json_' + jsonKey.toLowerCase().replace(/[^a-z0-9]/g, '_');
    const newFields = { ...config.fields };
    newFields[fieldId] = {
      enabled: true,
      type: 'fuzzy',
      threshold: 85,
      jsonKey: jsonKey,
      sourceField: 'bahr_import_flatpack_data',
      isCustom: true,
      isJsonField: true,
      label: jsonKey,
    };
    onChange({ ...config, preset: 'custom', fields: newFields });
    setShowJsonFields(false);
  };

  const handleRemoveCustomField = (fieldId) => {
    const newFields = { ...config.fields };
    delete newFields[fieldId];
    onChange({ ...config, preset: 'custom', fields: newFields });
  };

  // Group fields by category
  const fieldsByCategory = useMemo(() => {
    const categories = {
      primary: { title: 'Primary Matching', fields: [] },
      identity: { title: 'Identity Fields', fields: [] },
      contact: { title: 'Contact Information', fields: [] },
      personal: { title: 'Personal Information', fields: [] },
      additional: { title: 'Additional Fields', fields: [] },
      custom: { title: 'Custom Fields', fields: [] },
      json: { title: 'JSON Fields (from bahr_import_flatpack_data)', fields: [] },
    };

    // Add predefined fields
    Object.entries(MATCH_FIELD_DEFINITIONS).forEach(([id, def]) => {
      const fieldConfig = config.fields[id] || { enabled: def.defaultEnabled, type: def.defaultType, threshold: def.defaultThreshold };
      categories[def.category].fields.push({ ...def, ...fieldConfig, id });
    });

    // Add custom fields (split by type)
    Object.entries(config.fields).forEach(([id, fieldConfig]) => {
      if (fieldConfig.isCustom) {
        if (fieldConfig.isJsonField) {
          // JSON field
          categories.json.fields.push({
            id,
            label: fieldConfig.label || fieldConfig.jsonKey,
            description: `From JSON field: bahr_import_flatpack_data.${fieldConfig.jsonKey}`,
            supportsFuzzy: true,
            isCustom: true,
            isJsonField: true,
            badge: 'json',
            ...fieldConfig,
          });
        } else {
          // Regular custom field
          categories.custom.fields.push({
            id,
            label: fieldConfig.label || fieldConfig.airtableField,
            description: `Custom field: ${fieldConfig.airtableField}`,
            supportsFuzzy: true,
            isCustom: true,
            ...fieldConfig,
          });
        }
      }
    });

    return categories;
  }, [config.fields]);

  const renderFieldRow = (field) => {
    const isDisabled = field.isBlocking;
    const showThreshold = field.supportsFuzzy && (field.type === 'fuzzy' || field.type === 'normalized');

    return (
      <div key={field.id} className="match-field-row">
        <div className={`match-field-toggle ${!field.enabled ? 'disabled' : ''}`}>
          <input
            type="checkbox"
            id={`field-${field.id}`}
            checked={field.enabled}
            onChange={() => handleFieldToggle(field.id)}
            disabled={isDisabled || disabled}
          />
          <label htmlFor={`field-${field.id}`}>
            {field.label}
            {field.recommended && <span className="field-badge recommended">Recommended</span>}
            {field.badge === 'id' && <span className="field-badge id">ID</span>}
            {field.badge === 'blocking' && <span className="field-badge blocking">Blocking</span>}
            {field.badge === 'json' && <span className="field-badge" style={{ background: 'rgba(147, 51, 234, 0.2)', color: '#a78bfa' }}>JSON</span>}
          </label>
          <span className="field-tooltip">
            <span className="tooltip-icon">?</span>
            <span className="tooltip-text">{field.description}</span>
          </span>
        </div>

        <div className="match-field-controls">
          <select
            className="match-type-select"
            value={field.type}
            onChange={(e) => handleFieldTypeChange(field.id, e.target.value)}
            disabled={!field.enabled || isDisabled || disabled}
          >
            {field.isBlocking ? (
              <option value="blocking">Blocking (if different = no match)</option>
            ) : (
              <>
                <option value="exact">Exact Match</option>
                {field.supportsFuzzy && <option value="fuzzy">Fuzzy Match</option>}
                {field.id === 'phone' && <option value="normalized">Normalized</option>}
              </>
            )}
          </select>

          {showThreshold && field.enabled && !isDisabled && (
            <div className="threshold-slider">
              <input
                type="range"
                min="50"
                max="100"
                value={field.threshold}
                onChange={(e) => handleThresholdChange(field.id, e.target.value)}
                disabled={disabled}
              />
              <span className="threshold-value">{field.threshold}%</span>
            </div>
          )}

          {field.isCustom && (
            <button
              className="secondary small"
              onClick={() => handleRemoveCustomField(field.id)}
              disabled={disabled}
              style={{ marginLeft: 'auto' }}
            >
              Remove
            </button>
          )}
        </div>
      </div>
    );
  };

  const activeFieldCount = Object.values(config.fields).filter(f => f.enabled).length;
  const totalFieldCount = Object.keys(config.fields).length;

  return (
    <div className="match-settings-panel">
      <div className="match-settings-header" onClick={() => setExpanded(!expanded)}>
        <h3>
          <span>Match Settings</span>
          <span style={{ fontSize: '0.8em', color: '#64748b', fontWeight: 'normal' }}>
            ({activeFieldCount} of {totalFieldCount} fields active)
          </span>
        </h3>
        <span className={`match-settings-toggle ${expanded ? 'expanded' : ''}`}>â–¼</span>
      </div>

      {expanded && (
        <div className="match-settings-body">
          {/* Presets */}
          <div className="match-settings-presets">
            <span style={{ color: '#94a3b8', marginRight: '10px', alignSelf: 'center' }}>Preset:</span>
            {Object.values(MATCH_PRESETS).map(preset => (
              <button
                key={preset.id}
                className={`preset-btn ${config.preset === preset.id ? 'active' : ''}`}
                onClick={() => handlePresetChange(preset.id)}
                title={preset.description}
                disabled={disabled}
              >
                {preset.name}
              </button>
            ))}
            {config.preset === 'custom' && (
              <span className="preset-btn active" style={{ cursor: 'default' }}>Custom</span>
            )}
          </div>

          {/* Primary & Identity Fields (always visible) */}
          {['primary', 'identity', 'contact', 'personal'].map(categoryKey => {
            const category = fieldsByCategory[categoryKey];
            if (category.fields.length === 0) return null;
            return (
              <div key={categoryKey} className="match-field-section">
                <div className="match-field-section-title">{category.title}</div>
                {category.fields.map(renderFieldRow)}
              </div>
            );
          })}

          {/* Additional Fields (collapsible) */}
          {(showAllFields || fieldsByCategory.additional.fields.some(f => config.fields[f.id]?.enabled)) && (
            <div className="match-field-section">
              <div className="match-field-section-title">
                Additional Fields
                {!showAllFields && (
                  <button className="expand-toggle" onClick={() => setShowAllFields(true)} disabled={disabled}>
                    Show all
                  </button>
                )}
              </div>
              {(showAllFields ? fieldsByCategory.additional.fields : fieldsByCategory.additional.fields.filter(f => config.fields[f.id]?.enabled)).map(renderFieldRow)}
            </div>
          )}

          {!showAllFields && !fieldsByCategory.additional.fields.some(f => config.fields[f.id]?.enabled) && (
            <button className="expand-toggle" onClick={() => setShowAllFields(true)} style={{ marginBottom: '15px' }} disabled={disabled}>
              + Show Additional Fields (Address, City, State, Country)
            </button>
          )}

          {/* Custom Fields */}
          {fieldsByCategory.custom.fields.length > 0 && (
            <div className="match-field-section">
              <div className="match-field-section-title">Custom Fields</div>
              {fieldsByCategory.custom.fields.map(renderFieldRow)}
            </div>
          )}

          {/* Add Custom Field */}
          {schema && availableCustomFields.length > 0 && (
            <div style={{ marginTop: '15px' }}>
              {showAddField ? (
                <div style={{ display: 'flex', gap: '10px', alignItems: 'center', flexWrap: 'wrap' }}>
                  <select
                    className="match-type-select"
                    style={{ minWidth: '200px' }}
                    onChange={(e) => e.target.value && handleAddCustomField(e.target.value)}
                    disabled={disabled}
                    defaultValue=""
                  >
                    <option value="" disabled>Select a field to add...</option>
                    {availableCustomFields.map(fieldName => (
                      <option key={fieldName} value={fieldName}>{fieldName}</option>
                    ))}
                  </select>
                  <button className="secondary small" onClick={() => setShowAddField(false)} disabled={disabled}>Cancel</button>
                </div>
              ) : (
                <button
                  className="secondary small"
                  onClick={() => setShowAddField(true)}
                  disabled={disabled}
                >
                  + Add Custom Field
                </button>
              )}
            </div>
          )}

          {/* JSON Fields from bahr_import_flatpack_data */}
          {fieldsByCategory.json.fields.length > 0 && (
            <div className="match-field-section">
              <div className="match-field-section-title" style={{ color: '#a78bfa' }}>
                JSON Fields (from bahr_import_flatpack_data)
              </div>
              {fieldsByCategory.json.fields.map(renderFieldRow)}
            </div>
          )}

          {/* Add JSON Field */}
          {availableJsonKeys.length > 0 && (
            <div style={{ marginTop: '15px' }}>
              {showJsonFields ? (
                <div style={{ display: 'flex', gap: '10px', alignItems: 'center', flexWrap: 'wrap' }}>
                  <select
                    className="match-type-select"
                    style={{ minWidth: '250px' }}
                    onChange={(e) => e.target.value && handleAddJsonField(e.target.value)}
                    disabled={disabled}
                    defaultValue=""
                  >
                    <option value="" disabled>Select a JSON field key to add...</option>
                    {availableJsonKeys.map(item => (
                      <option key={item.key} value={item.key}>
                        {item.key} ({item.count} records)
                      </option>
                    ))}
                  </select>
                  <button className="secondary small" onClick={() => setShowJsonFields(false)} disabled={disabled}>Cancel</button>
                </div>
              ) : (
                <button
                  className="secondary small"
                  onClick={() => setShowJsonFields(true)}
                  disabled={disabled}
                  style={{ background: 'rgba(147, 51, 234, 0.2)', borderColor: '#7c3aed' }}
                >
                  + Add JSON Field ({availableJsonKeys.length} available)
                </button>
              )}
            </div>
          )}

          {/* Footer with Re-scan button */}
          <div className="match-settings-footer">
            <div className="settings-info">
              {config.preset !== 'custom'
                ? `Using ${MATCH_PRESETS[config.preset]?.name || 'Balanced'} preset`
                : 'Using custom configuration'}
            </div>
            <button
              className="primary"
              onClick={onRescan}
              disabled={disabled || !allRecords || allRecords.length === 0}
            >
              Re-Scan with These Settings
            </button>
          </div>
        </div>
      )}
    </div>
  );
}

// ============================================
// LOGIN COMPONENT
// ============================================

function LoginScreen({ onLogin }) {
  const [password, setPassword] = useState('');
  const [error, setError] = useState('');
  const [loading, setLoading] = useState(false);

  const handleSubmit = async (e) => {
    e.preventDefault();
    setLoading(true);
    try {
      const hash = await hashPassword(password);
      if (hash === ALL_CLIENTS_HASH) onLogin('all');
      else if (hash === BAHR_ONLY_HASH) onLogin('bahr');
      else setError('Invalid password');
    } catch { setError('Authentication error'); }
    finally { setLoading(false); }
  };

  return (
    <div className="container" style={{ display: 'flex', alignItems: 'center', justifyContent: 'center', minHeight: '100vh' }}>
      <div className="card" style={{ maxWidth: '400px', width: '100%' }}>
        <h1 style={{ textAlign: 'center' }}>Airtable Dedupe</h1>
        <p className="subtitle" style={{ textAlign: 'center' }}>Deduplication Tool</p>
        <form onSubmit={handleSubmit}>
          <div className="input-group">
            <label>Password</label>
            <input type="password" value={password} onChange={e => setPassword(e.target.value)} placeholder="Enter access password" autoFocus />
          </div>
          {error && <div style={{ color: '#ef4444', marginBottom: '15px', textAlign: 'center' }}>{error}</div>}
          <button type="submit" className="primary" disabled={loading || !password} style={{ width: '100%' }}>
            {loading ? 'Verifying...' : 'Login'}
          </button>
        </form>
      </div>
    </div>
  );
}

// ============================================
// TABLE SELECTOR COMPONENT
// ============================================

function TableSelector({ onSelectTable, onBack }) {
  const tableOptions = Object.values(TABLE_CONFIGS);

  return (
    <div className="container" style={{ display: 'flex', alignItems: 'center', justifyContent: 'center', minHeight: '100vh' }}>
      <div className="card" style={{ maxWidth: '600px', width: '100%' }}>
        <div style={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', marginBottom: '20px' }}>
          <button className="secondary small" onClick={onBack}>
            â† Back
          </button>
          <div></div>
        </div>
        <h1 style={{ textAlign: 'center', marginBottom: '10px' }}>Select Table</h1>
        <p className="subtitle" style={{ textAlign: 'center', marginBottom: '30px' }}>
          Choose which Airtable table to scan for duplicates
        </p>

        <div style={{ display: 'grid', gap: '15px' }}>
          {tableOptions.map(table => (
            <div
              key={table.id}
              onClick={() => onSelectTable(table.id)}
              style={{
                background: 'rgba(30, 41, 59, 0.9)',
                border: '1px solid #475569',
                borderRadius: '12px',
                padding: '20px',
                cursor: 'pointer',
                transition: 'all 0.2s',
                display: 'flex',
                alignItems: 'flex-start',
                gap: '15px',
              }}
              onMouseEnter={e => {
                e.currentTarget.style.borderColor = '#6366f1';
                e.currentTarget.style.transform = 'translateY(-2px)';
              }}
              onMouseLeave={e => {
                e.currentTarget.style.borderColor = '#475569';
                e.currentTarget.style.transform = 'translateY(0)';
              }}
            >
              <div style={{
                fontSize: '2.5rem',
                lineHeight: 1,
                background: 'rgba(99, 102, 241, 0.15)',
                borderRadius: '12px',
                padding: '12px',
              }}>
                {table.icon}
              </div>
              <div style={{ flex: 1 }}>
                <h3 style={{ color: '#a5b4fc', marginBottom: '5px', fontSize: '1.1em' }}>
                  {table.name}
                </h3>
                <p style={{ color: '#94a3b8', fontSize: '0.9em', marginBottom: '10px' }}>
                  {table.description}
                </p>
                <div style={{ display: 'flex', gap: '8px', flexWrap: 'wrap' }}>
                  {table.flatpackField && (
                    <span style={{
                      fontSize: '0.7em',
                      background: 'rgba(168, 85, 247, 0.2)',
                      color: '#a855f7',
                      padding: '3px 8px',
                      borderRadius: '4px',
                    }}>
                      Matter_Flatpack
                    </span>
                  )}
                  {table.hasBahrFilter && (
                    <span style={{
                      fontSize: '0.7em',
                      background: 'rgba(16, 185, 129, 0.2)',
                      color: '#10b981',
                      padding: '3px 8px',
                      borderRadius: '4px',
                    }}>
                      Bahr Filter
                    </span>
                  )}
                  <span style={{
                    fontSize: '0.7em',
                    background: 'rgba(59, 130, 246, 0.2)',
                    color: '#3b82f6',
                    padding: '3px 8px',
                    borderRadius: '4px',
                  }}>
                    {table.tableId.length > 15 ? `${table.tableId.slice(0, 15)}...` : table.tableId}
                  </span>
                </div>
              </div>
              <div style={{ color: '#64748b', fontSize: '1.5em' }}>â†’</div>
            </div>
          ))}
        </div>
      </div>
    </div>
  );
}

// ============================================
// MERGE REVIEW MODAL
// ============================================

function MergeReviewModal({ candidate, schema, credentials, onComplete, onSkip, onClose, addLog }) {
  const [notes, setNotes] = useState('');
  const [merging, setMerging] = useState(false);
  const [userOverrides, setUserOverrides] = useState({});

  const survivorFields = candidate.survivor.record.fields || {};
  const mergedFields = candidate.merged.record.fields || {};

  // Reset overrides when candidate changes
  const candidateId = candidate.id;
  useEffect(() => {
    setUserOverrides({});
  }, [candidateId]);

  // Get all unique field names
  const allFieldNames = useMemo(() => {
    const names = new Set([...Object.keys(survivorFields), ...Object.keys(mergedFields)]);
    return Array.from(names).sort();
  }, [survivorFields, mergedFields]);

  // Compute decisions with auto-resolve - always returns complete decisions
  const fieldDecisions = useMemo(() => {
    const decisions = {};
    const isEmpty = (v) => v === null || v === undefined || (typeof v === 'string' && !v.trim()) || (Array.isArray(v) && v.length === 0);

    allFieldNames.forEach(fieldName => {
      // Check for user override first
      if (userOverrides[fieldName]) {
        decisions[fieldName] = userOverrides[fieldName];
        return;
      }

      const isComputed = schema.computedFields.includes(fieldName);
      const isExcluded = EXCLUDE_FROM_MERGE.includes(fieldName);
      const valA = survivorFields[fieldName];
      const valB = mergedFields[fieldName];

      if (isComputed || isExcluded) {
        decisions[fieldName] = { strategy: 'skip', value: null, include: false };
      } else if (JSON.stringify(valA) === JSON.stringify(valB)) {
        decisions[fieldName] = { strategy: 'auto', value: valA, include: !isEmpty(valA) };
      } else if (isEmpty(valA) && !isEmpty(valB)) {
        decisions[fieldName] = { strategy: 'keep_b', value: valB, include: true };
      } else if (!isEmpty(valA) && isEmpty(valB)) {
        decisions[fieldName] = { strategy: 'keep_a', value: valA, include: true };
      } else if (schema.linkFields.includes(fieldName)) {
        // Merge link fields
        const merged = [...new Set([...(valA || []), ...(valB || [])])];
        decisions[fieldName] = { strategy: 'merge', value: merged, include: merged.length > 0 };
      } else {
        // Auto-resolve conflict using smart rules
        const resolution = autoResolveConflict(fieldName, valA, valB, survivorFields, mergedFields);
        decisions[fieldName] = {
          strategy: resolution.strategy,
          value: resolution.value,
          include: true,
          needsDecision: false,
          autoResolved: true,
          reason: resolution.reason
        };
      }
    });
    return decisions;
  }, [allFieldNames, survivorFields, mergedFields, schema, userOverrides]);

  const pendingDecisions = Object.entries(fieldDecisions).filter(([_, d]) => d.needsDecision);

  const handlePick = (fieldName, pick) => {
    const valA = survivorFields[fieldName];
    const valB = mergedFields[fieldName];
    setUserOverrides(prev => ({
      ...prev,
      [fieldName]: { strategy: pick, value: pick === 'keep_a' ? valA : valB, include: true, needsDecision: false }
    }));
  };

  const handleMerge = async () => {
    if (pendingDecisions.length > 0) {
      addLog(`Please resolve ${pendingDecisions.length} field conflict(s) first`, 'error');
      return;
    }

    setMerging(true);
    try {
      const client = new AirtableClient(credentials.apiKey, credentials.baseId);

      // Check if Box folder migration is needed and send webhook
      let boxMigrationRecord = null;
      const boxMigration = getBoxMigrationInfo(survivorFields, mergedFields);
      if (boxMigration.needsMigration) {
        addLog(`Box migration needed: ${boxMigration.deleteBoxFolderId} -> ${boxMigration.keepBoxFolderId}`, 'info');

        const webhookResult = await sendBoxMigrationWebhook(null, {
          survivorRecordId: candidate.survivor.record.id,
          survivorRecordName: candidate.survivor.name,
          mergedRecordId: candidate.merged.record.id,
          mergedRecordName: candidate.merged.name,
          keepBoxFolderId: boxMigration.keepBoxFolderId,
          deleteBoxFolderId: boxMigration.deleteBoxFolderId,
          keepBoxUrl: boxMigration.keepBoxUrl,
          deleteBoxUrl: boxMigration.deleteBoxUrl,
          keepBoxName: boxMigration.keepBoxName,
          deleteBoxName: boxMigration.deleteBoxName
        });

        // Record webhook result for history
        boxMigrationRecord = {
          keepBoxFolderId: boxMigration.keepBoxFolderId,
          deleteBoxFolderId: boxMigration.deleteBoxFolderId,
          keepBoxUrl: boxMigration.keepBoxUrl,
          deleteBoxUrl: boxMigration.deleteBoxUrl,
          webhookSent: webhookResult.success,
          webhookSentAt: new Date().toISOString(),
          webhookResponse: webhookResult.result || null,
          webhookError: webhookResult.error || null,
          migrationConfirmed: webhookResult.result?.migrationConfirmed || false,
          migrationConfirmedAt: webhookResult.result?.migrationConfirmedAt || null
        };

        if (webhookResult.success) {
          addLog(`Box migration webhook sent successfully`, 'success');
          if (webhookResult.result?.migrationConfirmed) {
            addLog(`Migration confirmed by n8n`, 'success');
          }
        } else {
          addLog(`Box migration webhook failed: ${webhookResult.error}`, 'warning');
        }
      }

      // Build update payload
      const updateFields = {};
      Object.entries(fieldDecisions).forEach(([fieldName, decision]) => {
        if (decision.include && !schema.computedFields.includes(fieldName) && !EXCLUDE_FROM_MERGE.includes(fieldName)) {
          updateFields[fieldName] = decision.value;
        }
      });

      // Build history entry with box migration info
      const historyEntry = buildMergeHistoryEntry(candidate.survivor, candidate.merged, fieldDecisions, candidate, notes, boxMigrationRecord);
      // Use append-only function to ensure we never lose existing history
      updateFields['dedupe_history'] = appendToDedupeHistory(survivorFields['dedupe_history'], historyEntry);

      addLog(`Merging ${candidate.merged.name} into ${candidate.survivor.name}...`, 'info');
      await client.updateRecord(credentials.tableName, candidate.survivor.record.id, updateFields);
      addLog('Survivor record updated', 'success');

      addLog(`Deleting merged record ${candidate.merged.record.id}...`, 'info');
      await client.deleteRecord(credentials.tableName, candidate.merged.record.id);
      addLog('Merged record deleted', 'success');

      onComplete(historyEntry);
    } catch (err) {
      addLog(`Merge failed: ${err.message}`, 'error');
    } finally {
      setMerging(false);
    }
  };

  const formatValue = (val) => {
    if (val === null || val === undefined) return null;
    if (Array.isArray(val)) return val.length === 0 ? null : `[${val.length} items]`;
    if (typeof val === 'boolean') return val ? 'Yes' : 'No';
    const str = String(val);
    return str.length > 50 ? str.slice(0, 50) + '...' : str;
  };

  return (
    <div className="modal-overlay" onClick={onClose}>
      <div className="modal" onClick={e => e.stopPropagation()}>
        <div className="modal-header">
          <div>
            <h2>Review Merge</h2>
            <div style={{ display: 'flex', alignItems: 'center', gap: '10px', marginTop: '5px' }}>
              <span className={`badge tier${candidate.tier.tier}`}>{candidate.confidence}%</span>
              <span style={{ color: '#94a3b8' }}>{candidate.tier.name} Match</span>
              <div style={{ display: 'flex', gap: '5px', marginLeft: '10px' }}>
                {candidate.reasons.map((r, i) => <span key={i} className="reason-tag">{r}</span>)}
              </div>
            </div>
          </div>
          <button className="modal-close" onClick={onClose}>&times;</button>
        </div>

        <div className="modal-body">
          {candidate.conflicts && candidate.conflicts.length > 0 && (
            <div style={{ background: 'rgba(239, 68, 68, 0.1)', border: '1px solid #ef4444', borderRadius: '8px', padding: '15px', marginBottom: '15px' }}>
              <strong style={{ color: '#ef4444' }}>Warning: Data Conflicts:</strong>
              <ul style={{ margin: '10px 0 0 20px', color: '#ef4444' }}>
                {candidate.conflicts.map((c, i) => <li key={i}>{c}</li>)}
              </ul>
            </div>
          )}

          <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '15px', marginBottom: '15px' }}>
            <div style={{ background: 'rgba(16, 185, 129, 0.1)', border: '1px solid #10b981', borderRadius: '8px', padding: '15px' }}>
              <div style={{ display: 'flex', alignItems: 'center', gap: '10px', marginBottom: '5px' }}>
                <span className="badge keep">KEEP</span>
                <strong>{candidate.survivor.name}</strong>
              </div>
              <div style={{ fontSize: '0.85em', color: '#94a3b8' }}>Score: {candidate.survivor.score} | ID: {candidate.survivor.record.id}</div>
            </div>
            <div style={{ background: 'rgba(245, 158, 11, 0.1)', border: '1px solid #f59e0b', borderRadius: '8px', padding: '15px' }}>
              <div style={{ display: 'flex', alignItems: 'center', gap: '10px', marginBottom: '5px' }}>
                <span className="badge merge">MERGE</span>
                <strong>{candidate.merged.name}</strong>
              </div>
              <div style={{ fontSize: '0.85em', color: '#94a3b8' }}>Score: {candidate.merged.score} | ID: {candidate.merged.record.id}</div>
            </div>
          </div>

          <div className="diff-container">
            <div className="diff-header">Field</div>
            <div className="diff-header">Record A (Keep)</div>
            <div className="diff-header">Record B (Merge)</div>
            <div className="diff-header">Resolution</div>

            {allFieldNames.map(fieldName => {
              const decision = fieldDecisions[fieldName] || {};
              const valA = survivorFields[fieldName];
              const valB = mergedFields[fieldName];
              const isComputed = schema.computedFields.includes(fieldName);
              const isExcluded = EXCLUDE_FROM_MERGE.includes(fieldName);
              const isSame = JSON.stringify(valA) === JSON.stringify(valB);
              const dispA = formatValue(valA);
              const dispB = formatValue(valB);

              return (
                <div key={fieldName} className="diff-row">
                  <div className={`diff-cell field-name ${isComputed ? 'computed' : ''}`}>
                    {fieldName}
                    {isComputed && <span style={{ fontSize: '0.7em', marginLeft: '5px' }}>(computed)</span>}
                    {isExcluded && <span style={{ fontSize: '0.7em', marginLeft: '5px', color: '#f59e0b' }}>(excluded)</span>}
                  </div>
                  <div
                    className={`diff-cell ${isSame ? 'same' : 'different'} ${decision.strategy === 'keep_a' ? 'selected' : ''} ${!isSame && !isComputed && !isExcluded ? 'clickable' : ''}`}
                    onClick={() => !isSame && !isComputed && !isExcluded && setUserOverrides(prev => ({
                      ...prev,
                      [fieldName]: { strategy: 'keep_a', value: valA, include: true, needsDecision: false, autoResolved: false }
                    }))}
                  >
                    {dispA || <span className="empty-value">(empty)</span>}
                  </div>
                  <div
                    className={`diff-cell ${isSame ? 'same' : 'different'} ${decision.strategy === 'keep_b' ? 'selected' : ''} ${!isSame && !isComputed && !isExcluded ? 'clickable' : ''}`}
                    onClick={() => !isSame && !isComputed && !isExcluded && setUserOverrides(prev => ({
                      ...prev,
                      [fieldName]: { strategy: 'keep_b', value: valB, include: true, needsDecision: false, autoResolved: false }
                    }))}
                  >
                    {dispB || <span className="empty-value">(empty)</span>}
                  </div>
                  <div className="diff-cell">
                    {isComputed || isExcluded ? (
                      <span style={{ color: '#64748b', fontSize: '0.8em' }}>Skip</span>
                    ) : isSame ? (
                      <span className="pick-btn auto">Auto</span>
                    ) : decision.strategy === 'merge' ? (
                      <span className="pick-btn auto">Merged</span>
                    ) : decision.autoResolved ? (
                      <div style={{ display: 'flex', alignItems: 'center', gap: '5px' }}>
                        <span className={`pick-btn ${decision.strategy === 'keep_a' ? 'active' : ''}`} style={{ background: '#10b981', borderColor: '#10b981', color: 'white', cursor: 'default' }}>
                          {decision.strategy === 'keep_a' ? 'A' : 'B'}
                        </span>
                        <span style={{ fontSize: '0.7em', color: '#10b981' }} title={decision.reason}>Auto</span>
                      </div>
                    ) : (
                      <div className="pick-buttons">
                        <button className={`pick-btn ${decision.strategy === 'keep_a' ? 'active' : ''}`} onClick={() => handlePick(fieldName, 'keep_a')}>A</button>
                        <button className={`pick-btn ${decision.strategy === 'keep_b' ? 'active' : ''}`} onClick={() => handlePick(fieldName, 'keep_b')}>B</button>
                      </div>
                    )}
                  </div>
                </div>
              );
            })}
          </div>

          <div className="input-group" style={{ marginTop: '15px' }}>
            <label>Notes (optional)</label>
            <textarea value={notes} onChange={e => setNotes(e.target.value)} placeholder="Add any notes about this merge..." rows={2} />
          </div>

          {pendingDecisions.length > 0 && (
            <div style={{ color: '#f59e0b', textAlign: 'center', marginTop: '10px' }}>
              Please resolve {pendingDecisions.length} field conflict(s): {pendingDecisions.map(([n]) => n).join(', ')}
            </div>
          )}
        </div>

        <div className="modal-footer">
          <button className="secondary" onClick={onSkip} disabled={merging}>Skip</button>
          <button className="warning" onClick={onClose} disabled={merging}>Not a Duplicate</button>
          <button className="success" onClick={handleMerge} disabled={merging || pendingDecisions.length > 0}>
            {merging ? 'Merging...' : 'Merge Records'}
          </button>
        </div>
      </div>
    </div>
  );
}

// ============================================
// HISTORY VIEWER
// ============================================

// Helper to format a field value for display
const formatFieldValue = (value) => {
  if (value === null || value === undefined) return '(empty)';
  if (Array.isArray(value)) {
    if (value.length === 0) return '(empty)';
    return value.length <= 3 ? value.join(', ') : `${value.slice(0, 3).join(', ')} (+${value.length - 3} more)`;
  }
  if (typeof value === 'boolean') return value ? 'Yes' : 'No';
  if (typeof value === 'object') return JSON.stringify(value);
  const str = String(value);
  return str.length > 60 ? str.slice(0, 60) + '...' : str;
};

// Helper to get a human-readable name from a merged record
const getMergedRecordName = (mergedRecord) => {
  const fields = mergedRecord.field_snapshot || {};
  const firstName = fields['First Name'] || '';
  const lastName = fields['Family Name'] || '';
  if (firstName || lastName) return `${firstName} ${lastName}`.trim();
  return fields['Client Name'] || mergedRecord.original_record_id || 'Unknown';
};

// Component to display a single merged record's details
function MergedRecordDetails({ mergedRecord, eventIdx, recordIdx, onUnmerge, isUnmerged, unmergeInfo, unmerging, confirmUnmerge, setConfirmUnmerge }) {
  const fields = mergedRecord.field_snapshot || {};
  const importantFields = ['First Name', 'Family Name', 'Client Name', 'DOB', 'PPID', 'A#', 'Phone Number', 'Client Email', 'Country', 'Address Line 1'];
  const displayFields = importantFields.filter(f => fields[f]);
  const isConfirming = confirmUnmerge?.eventIdx === eventIdx && confirmUnmerge?.mergedRecordIdx === recordIdx;

  return (
    <div className="merged-record-card" style={isUnmerged ? { opacity: 0.6, borderColor: 'rgba(16, 185, 129, 0.3)', background: 'rgba(16, 185, 129, 0.05)' } : {}}>
      <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'flex-start', marginBottom: '10px' }}>
        <div>
          <h4 style={{ margin: 0 }}>
            <span style={{ fontSize: '1.1em' }}>{isUnmerged ? 'âœ…' : 'ðŸ“‹'}</span>
            {' '}{isUnmerged ? 'Restored:' : 'Merged record:'} {getMergedRecordName(mergedRecord)}
          </h4>
          <div style={{ fontSize: '0.8em', color: '#94a3b8', marginTop: '5px' }}>
            Original ID: <code style={{ background: '#0f172a', padding: '2px 6px', borderRadius: '4px' }}>{mergedRecord.original_record_id}</code>
          </div>
        </div>
        <div>
          {isUnmerged ? (
            <div style={{
              background: 'rgba(16, 185, 129, 0.2)',
              color: '#10b981',
              padding: '6px 12px',
              borderRadius: '6px',
              fontSize: '0.8em',
              fontWeight: '500'
            }}>
              Restored as {unmergeInfo?.restored_record_id}
              <div style={{ fontSize: '0.75em', opacity: 0.8, marginTop: '2px' }}>
                {new Date(unmergeInfo?.unmerged_at).toLocaleDateString()}
              </div>
            </div>
          ) : isConfirming ? (
            <div style={{ display: 'flex', gap: '8px', alignItems: 'center' }}>
              <span style={{ fontSize: '0.8em', color: '#f59e0b' }}>Restore this record?</span>
              <button
                className="success small"
                onClick={() => onUnmerge(eventIdx, recordIdx)}
                disabled={unmerging}
              >
                {unmerging ? 'Restoring...' : 'Yes, Restore'}
              </button>
              <button
                className="secondary small"
                onClick={() => setConfirmUnmerge(null)}
                disabled={unmerging}
              >
                Cancel
              </button>
            </div>
          ) : (
            <button
              className="warning small"
              onClick={() => setConfirmUnmerge({ eventIdx, mergedRecordIdx: recordIdx })}
              title="Restore this record as a separate entry"
            >
              Undo Merge
            </button>
          )}
        </div>
      </div>
      {displayFields.length > 0 && (
        <table className="field-changes-table">
          <thead>
            <tr>
              <th style={{ width: '40%' }}>Field</th>
              <th>Value {isUnmerged ? 'that was restored' : 'at time of merge'}</th>
            </tr>
          </thead>
          <tbody>
            {displayFields.map(fieldName => (
              <tr key={fieldName}>
                <td style={{ color: '#94a3b8' }}>{fieldName}</td>
                <td>{formatFieldValue(fields[fieldName])}</td>
              </tr>
            ))}
          </tbody>
        </table>
      )}
    </div>
  );
}

function HistoryViewer({ credentials, addLog }) {
  const [searchQuery, setSearchQuery] = useState('');
  const [searchResults, setSearchResults] = useState([]);
  const [selectedRecord, setSelectedRecord] = useState(null);
  const [history, setHistory] = useState([]);
  const [expandedEvents, setExpandedEvents] = useState(new Set());
  const [searching, setSearching] = useState(false);
  const [detailTab, setDetailTab] = useState('summary'); // 'summary', 'fields', 'raw'
  const [unmerging, setUnmerging] = useState(false);
  const [confirmUnmerge, setConfirmUnmerge] = useState(null); // { eventIdx, mergedRecordIdx }

  const handleSearch = async () => {
    if (!searchQuery.trim()) return;
    setSearching(true);
    try {
      const client = new AirtableClient(credentials.apiKey, credentials.baseId);
      const filter = `OR(FIND(LOWER("${searchQuery.toLowerCase()}"), LOWER({Client Name})), FIND("${searchQuery}", {PPID}), RECORD_ID() = "${searchQuery}")`;
      const results = await client.getAllRecords(credentials.tableName, ['Client Name', 'PPID', 'dedupe_history', 'First Name', 'Family Name'], filter);
      setSearchResults(results);
      if (results.length === 0) addLog('No records found', 'warning');
      else addLog(`Found ${results.length} records`, 'success');
    } catch (err) {
      addLog(`Search failed: ${err.message}`, 'error');
    } finally {
      setSearching(false);
    }
  };

  const selectRecord = (record) => {
    setSelectedRecord(record);
    const hist = parseDedupeHistory(record.fields.dedupe_history);
    setHistory(hist);
    // Auto-expand first event if there's history
    if (hist.length > 0) {
      setExpandedEvents(new Set([hist[0].merge_id || 0]));
    }
  };

  const toggleEvent = (id) => {
    setExpandedEvents(prev => {
      const next = new Set(prev);
      if (next.has(id)) next.delete(id);
      else next.add(id);
      return next;
    });
  };

  const formatDate = (timestamp) => {
    const date = new Date(timestamp);
    return date.toLocaleDateString('en-US', {
      month: 'short',
      day: 'numeric',
      year: 'numeric',
      hour: 'numeric',
      minute: '2-digit'
    });
  };

  const getActionDescription = (event) => {
    if (event.action === 'merge') {
      const count = event.merged_records?.length || 0;
      const names = event.merged_records?.map(r => getMergedRecordName(r)).join(', ') || 'unknown record';
      return count === 1
        ? `Merged "${names}" into this record`
        : `Merged ${count} records into this record`;
    }
    return 'Record was unmerged';
  };

  const handleUnmerge = async (eventIdx, mergedRecordIdx) => {
    if (!selectedRecord || !credentials.apiKey) return;

    setUnmerging(true);
    try {
      const client = new AirtableClient(credentials.apiKey, credentials.baseId);
      const event = history[eventIdx];
      const mergedRecord = event.merged_records[mergedRecordIdx];

      if (!mergedRecord?.field_snapshot) {
        addLog('Cannot unmerge: no field snapshot available', 'error');
        return;
      }

      addLog(`Restoring record: ${getMergedRecordName(mergedRecord)}...`, 'info');

      // Filter out computed fields and prepare writable fields
      const fieldsToRestore = { ...mergedRecord.field_snapshot };
      // Remove fields that shouldn't be restored
      delete fieldsToRestore.dedupe_history;

      // Create the restored record
      const restored = await client.createRecord(credentials.tableName, fieldsToRestore);
      addLog(`Record restored with new ID: ${restored.id}`, 'success');

      // Fetch fresh history from Airtable to ensure append-only behavior
      addLog('Fetching current history from database...', 'info');
      const freshRecord = await client.getRecord(credentials.tableName, selectedRecord.id);
      const currentHistoryField = freshRecord?.fields?.dedupe_history;

      // Use safe update function to ensure we never lose history
      const updatedHistoryJson = updateDedupeHistorySafely(currentHistoryField, (historyArray) => {
        // Find the event by merge_id to ensure we update the correct one
        const targetEvent = historyArray.find(e => e.merge_id === event.merge_id);
        if (!targetEvent) {
          throw new Error('Cannot find merge event in current history - history may have changed');
        }
        if (!targetEvent.unmerged_records) {
          targetEvent.unmerged_records = [];
        }
        targetEvent.unmerged_records.push({
          original_record_id: mergedRecord.original_record_id,
          restored_record_id: restored.id,
          unmerged_at: new Date().toISOString(),
          unmerged_by: 'user'
        });
        return historyArray;
      });

      // Update the survivor record's history
      await client.updateRecord(credentials.tableName, selectedRecord.id, {
        dedupe_history: updatedHistoryJson
      });

      // Update local state with fresh parsed history
      setHistory(parseDedupeHistory(updatedHistoryJson));
      addLog('Unmerge completed successfully!', 'success');
      setConfirmUnmerge(null);

    } catch (err) {
      addLog(`Unmerge failed: ${err.message}`, 'error');
    } finally {
      setUnmerging(false);
    }
  };

  const isRecordUnmerged = (event, mergedRecordIdx) => {
    if (!event.unmerged_records) return false;
    const mergedRecord = event.merged_records[mergedRecordIdx];
    return event.unmerged_records.some(
      u => u.original_record_id === mergedRecord.original_record_id
    );
  };

  const getUnmergeInfo = (event, mergedRecordIdx) => {
    if (!event.unmerged_records) return null;
    const mergedRecord = event.merged_records[mergedRecordIdx];
    return event.unmerged_records.find(
      u => u.original_record_id === mergedRecord.original_record_id
    );
  };

  return (
    <div className="card">
      <h2>Merge History</h2>
      <p className="subtitle">Search for a client to see their complete merge history</p>

      <div style={{ display: 'flex', gap: '10px', marginBottom: '20px' }}>
        <input type="text" value={searchQuery} onChange={e => setSearchQuery(e.target.value)}
          placeholder="Search by name, PPID, or record ID..." style={{ flex: 1 }}
          onKeyDown={e => e.key === 'Enter' && handleSearch()} />
        <button className="primary" onClick={handleSearch} disabled={searching}>
          {searching ? 'Searching...' : 'Search'}
        </button>
      </div>

      {searchResults.length > 0 && (
        <div style={{ marginBottom: '20px' }}>
          <h3 style={{ marginBottom: '10px' }}>Search Results ({searchResults.length})</h3>
          <div style={{ maxHeight: '200px', overflowY: 'auto' }}>
            {searchResults.map(record => {
              const historyCount = parseDedupeHistory(record.fields.dedupe_history).length;
              return (
                <div key={record.id} onClick={() => selectRecord(record)}
                  style={{
                    padding: '12px 15px',
                    background: selectedRecord?.id === record.id ? 'rgba(99, 102, 241, 0.2)' : '#1e293b',
                    borderRadius: '8px',
                    marginBottom: '8px',
                    cursor: 'pointer',
                    border: selectedRecord?.id === record.id ? '1px solid rgba(99, 102, 241, 0.5)' : '1px solid transparent',
                    display: 'flex',
                    alignItems: 'center',
                    justifyContent: 'space-between'
                  }}>
                  <div>
                    <div style={{ fontWeight: '500', marginBottom: '4px' }}>{record.fields['Client Name'] || getDisplayName(record)}</div>
                    <div style={{ fontSize: '0.8em', color: '#94a3b8' }}>
                      {record.fields.PPID && <span style={{ marginRight: '10px' }}>PPID: {record.fields.PPID}</span>}
                      <span style={{ opacity: 0.7 }}>ID: {record.id}</span>
                    </div>
                  </div>
                  {historyCount > 0 && (
                    <div style={{
                      background: 'rgba(16, 185, 129, 0.2)',
                      color: '#10b981',
                      padding: '4px 10px',
                      borderRadius: '12px',
                      fontSize: '0.8em',
                      fontWeight: '500'
                    }}>
                      {historyCount} merge{historyCount !== 1 ? 's' : ''}
                    </div>
                  )}
                </div>
              );
            })}
          </div>
        </div>
      )}

      {selectedRecord && (
        <div>
          <div style={{
            background: 'rgba(99, 102, 241, 0.1)',
            border: '1px solid rgba(99, 102, 241, 0.3)',
            borderRadius: '10px',
            padding: '15px 20px',
            marginBottom: '20px'
          }}>
            <h3 style={{ margin: 0, color: '#a5b4fc' }}>
              {selectedRecord.fields['Client Name'] || getDisplayName(selectedRecord)}
            </h3>
            <div style={{ fontSize: '0.85em', color: '#94a3b8', marginTop: '5px' }}>
              {history.length === 0
                ? 'No merge history - this record has not been involved in any merges'
                : `${history.length} merge operation${history.length !== 1 ? 's' : ''} recorded`}
            </div>
          </div>

          {history.length === 0 ? (
            <div style={{
              color: '#94a3b8',
              textAlign: 'center',
              padding: '40px 20px',
              background: '#0f172a',
              borderRadius: '8px'
            }}>
              <div style={{ fontSize: '2em', marginBottom: '10px' }}>ðŸ“­</div>
              <div>No merge history for this record</div>
              <div style={{ fontSize: '0.85em', marginTop: '5px', opacity: 0.7 }}>
                History will appear here after merges are performed
              </div>
            </div>
          ) : (
            <div>
              {history.map((event, idx) => {
                const eventId = event.merge_id || idx;
                const isExpanded = expandedEvents.has(eventId);

                return (
                  <div key={eventId} className={`history-event ${event.action}`}>
                    <div className="history-event-header" onClick={() => toggleEvent(eventId)}>
                      <div className={`history-icon ${event.action === 'merge' ? 'merge-icon' : 'unmerge-icon'}`}>
                        {event.action === 'merge' ? 'ðŸ”€' : 'â†©ï¸'}
                      </div>
                      <div style={{ flex: 1 }}>
                        <div style={{ fontWeight: '500', marginBottom: '4px' }}>
                          {getActionDescription(event)}
                        </div>
                        <div style={{ fontSize: '0.85em', color: '#94a3b8', display: 'flex', gap: '15px', flexWrap: 'wrap' }}>
                          <span>ðŸ“… {formatDate(event.timestamp)}</span>
                          <span style={{
                            background: event.confidence >= 90 ? 'rgba(16, 185, 129, 0.2)' :
                                        event.confidence >= 70 ? 'rgba(99, 102, 241, 0.2)' : 'rgba(245, 158, 11, 0.2)',
                            color: event.confidence >= 90 ? '#10b981' :
                                   event.confidence >= 70 ? '#a5b4fc' : '#f59e0b',
                            padding: '2px 8px',
                            borderRadius: '4px'
                          }}>
                            {event.confidence}% confidence
                          </span>
                        </div>
                      </div>
                      <span style={{
                        color: '#64748b',
                        transition: 'transform 0.2s',
                        transform: isExpanded ? 'rotate(180deg)' : 'rotate(0deg)'
                      }}>â–¼</span>
                    </div>

                    {isExpanded && (
                      <div className="history-event-body">
                        {/* Tabs for different views */}
                        <div className="history-tabs">
                          <button
                            className={`history-tab ${detailTab === 'summary' ? 'active' : ''}`}
                            onClick={() => setDetailTab('summary')}
                          >
                            Summary
                          </button>
                          <button
                            className={`history-tab ${detailTab === 'fields' ? 'active' : ''}`}
                            onClick={() => setDetailTab('fields')}
                          >
                            Merged Data
                          </button>
                          <button
                            className={`history-tab ${detailTab === 'raw' ? 'active' : ''}`}
                            onClick={() => setDetailTab('raw')}
                          >
                            Raw Data
                          </button>
                        </div>

                        {detailTab === 'summary' && (
                          <div>
                            {/* Summary cards */}
                            <div className="history-summary">
                              <div className="history-summary-item">
                                <div className="label">Why they matched</div>
                                <div className="value">
                                  {event.match_reasons?.map((r, i) => (
                                    <span key={i} className="reason-tag" style={{ marginRight: '5px', marginBottom: '5px' }}>{r}</span>
                                  ))}
                                </div>
                              </div>
                              <div className="history-summary-item">
                                <div className="label">Performed by</div>
                                <div className="value">{event.performed_by || 'User'}</div>
                              </div>
                              <div className="history-summary-item">
                                <div className="label">Records merged</div>
                                <div className="value">{event.merged_records?.length || 0}</div>
                              </div>
                              {event.unmerged_records?.length > 0 && (
                                <div className="history-summary-item" style={{ background: 'rgba(16, 185, 129, 0.1)', borderColor: 'rgba(16, 185, 129, 0.3)' }}>
                                  <div className="label" style={{ color: '#10b981' }}>Records restored</div>
                                  <div className="value" style={{ color: '#10b981' }}>{event.unmerged_records.length}</div>
                                </div>
                              )}
                            </div>

                            {event.notes && (
                              <div style={{
                                background: 'rgba(245, 158, 11, 0.1)',
                                border: '1px solid rgba(245, 158, 11, 0.3)',
                                borderRadius: '8px',
                                padding: '12px 15px',
                                marginBottom: '15px'
                              }}>
                                <div style={{ fontSize: '0.8em', color: '#f59e0b', marginBottom: '5px' }}>Notes</div>
                                <div>{event.notes}</div>
                              </div>
                            )}

                            <div style={{ color: '#94a3b8', fontSize: '0.85em', marginTop: '15px' }}>
                              <strong>Merge ID:</strong> <code style={{ background: '#0f172a', padding: '2px 6px', borderRadius: '4px' }}>{event.merge_id}</code>
                            </div>

                            {/* Quick actions */}
                            {event.merged_records?.some((_, mIdx) => !isRecordUnmerged(event, mIdx)) && (
                              <div style={{
                                marginTop: '20px',
                                paddingTop: '15px',
                                borderTop: '1px solid #334155'
                              }}>
                                <div style={{ fontSize: '0.85em', color: '#94a3b8', marginBottom: '10px' }}>
                                  Quick Actions
                                </div>
                                <button
                                  className="warning"
                                  onClick={() => setDetailTab('fields')}
                                  style={{ display: 'flex', alignItems: 'center', gap: '8px' }}
                                >
                                  <span>â†©ï¸</span> View merged records to undo
                                </button>
                              </div>
                            )}
                          </div>
                        )}

                        {detailTab === 'fields' && (
                          <div>
                            {event.merged_records?.map((mergedRecord, mIdx) => (
                              <MergedRecordDetails
                                key={mIdx}
                                mergedRecord={mergedRecord}
                                eventIdx={idx}
                                recordIdx={mIdx}
                                onUnmerge={handleUnmerge}
                                isUnmerged={isRecordUnmerged(event, mIdx)}
                                unmergeInfo={getUnmergeInfo(event, mIdx)}
                                unmerging={unmerging}
                                confirmUnmerge={confirmUnmerge}
                                setConfirmUnmerge={setConfirmUnmerge}
                              />
                            ))}
                          </div>
                        )}

                        {detailTab === 'raw' && (
                          <div>
                            <div style={{ fontSize: '0.85em', color: '#94a3b8', marginBottom: '10px' }}>
                              Complete event data in JSON format:
                            </div>
                            <pre style={{
                              background: '#0f172a',
                              padding: '15px',
                              borderRadius: '8px',
                              overflow: 'auto',
                              maxHeight: '300px',
                              fontSize: '0.8em'
                            }}>{JSON.stringify(event, null, 2)}</pre>
                          </div>
                        )}
                      </div>
                    )}
                  </div>
                );
              })}
            </div>
          )}
        </div>
      )}
    </div>
  );
}

// ============================================
// BULK MERGE MODAL
// ============================================

function BulkMergeModal({ selectedCandidates, schema, credentials, onComplete, onClose, addLog }) {
  const [merging, setMerging] = useState(false);
  const [progress, setProgress] = useState({ current: 0, total: 0, status: 'pending' });
  const [results, setResults] = useState({ success: [], failed: [], boxFoldersToDelete: [] });
  const [autoResolveAll, setAutoResolveAll] = useState(true);

  const handleBulkMerge = async () => {
    if (selectedCandidates.length === 0) return;

    setMerging(true);
    setProgress({ current: 0, total: selectedCandidates.length, status: 'running' });
    const newResults = { success: [], failed: [], boxFoldersToDelete: [] };

    const client = new AirtableClient(credentials.apiKey, credentials.baseId);

    for (let i = 0; i < selectedCandidates.length; i++) {
      const candidate = selectedCandidates[i];
      setProgress({ current: i + 1, total: selectedCandidates.length, status: 'running' });

      try {
        const survivorFields = candidate.survivor.record.fields || {};
        const mergedFields = candidate.merged.record.fields || {};

        // Get all unique field names
        const allFieldNames = new Set([...Object.keys(survivorFields), ...Object.keys(mergedFields)]);
        const fieldDecisions = {};

        // Auto-resolve all fields
        allFieldNames.forEach(fieldName => {
          const isComputed = schema.computedFields.includes(fieldName);
          const isExcluded = EXCLUDE_FROM_MERGE.includes(fieldName);
          const valA = survivorFields[fieldName];
          const valB = mergedFields[fieldName];
          const isEmpty = (v) => v === null || v === undefined || (typeof v === 'string' && !v.trim()) || (Array.isArray(v) && v.length === 0);

          if (isComputed || isExcluded) {
            fieldDecisions[fieldName] = { strategy: 'skip', value: null, include: false };
          } else if (JSON.stringify(valA) === JSON.stringify(valB)) {
            fieldDecisions[fieldName] = { strategy: 'auto', value: valA, include: !isEmpty(valA) };
          } else if (isEmpty(valA) && !isEmpty(valB)) {
            fieldDecisions[fieldName] = { strategy: 'keep_b', value: valB, include: true };
          } else if (!isEmpty(valA) && isEmpty(valB)) {
            fieldDecisions[fieldName] = { strategy: 'keep_a', value: valA, include: true };
          } else if (schema.linkFields.includes(fieldName)) {
            // Merge link fields
            const merged = [...new Set([...(valA || []), ...(valB || [])])];
            fieldDecisions[fieldName] = { strategy: 'merge', value: merged, include: merged.length > 0 };
          } else {
            // Auto-resolve conflict using smart rules
            const resolution = autoResolveConflict(fieldName, valA, valB, survivorFields, mergedFields);
            fieldDecisions[fieldName] = { ...resolution, include: true };
          }
        });

        // Check if Box folder migration is needed and send webhook
        let boxMigrationRecord = null;
        const boxMigration = getBoxMigrationInfo(survivorFields, mergedFields);
        if (boxMigration.needsMigration) {
          addLog(`Box migration needed: ${boxMigration.deleteBoxFolderId} -> ${boxMigration.keepBoxFolderId}`, 'info');

          const webhookResult = await sendBoxMigrationWebhook(null, {
            survivorRecordId: candidate.survivor.record.id,
            survivorRecordName: candidate.survivor.name,
            mergedRecordId: candidate.merged.record.id,
            mergedRecordName: candidate.merged.name,
            keepBoxFolderId: boxMigration.keepBoxFolderId,
            deleteBoxFolderId: boxMigration.deleteBoxFolderId,
            keepBoxUrl: boxMigration.keepBoxUrl,
            deleteBoxUrl: boxMigration.deleteBoxUrl,
            keepBoxName: boxMigration.keepBoxName,
            deleteBoxName: boxMigration.deleteBoxName
          });

          // Record webhook result for history
          boxMigrationRecord = {
            keepBoxFolderId: boxMigration.keepBoxFolderId,
            deleteBoxFolderId: boxMigration.deleteBoxFolderId,
            keepBoxUrl: boxMigration.keepBoxUrl,
            deleteBoxUrl: boxMigration.deleteBoxUrl,
            webhookSent: webhookResult.success,
            webhookSentAt: new Date().toISOString(),
            webhookResponse: webhookResult.result || null,
            webhookError: webhookResult.error || null,
            migrationConfirmed: webhookResult.result?.migrationConfirmed || false,
            migrationConfirmedAt: webhookResult.result?.migrationConfirmedAt || null
          };

          if (webhookResult.success) {
            addLog(`Box migration webhook sent successfully`, 'success');
            if (webhookResult.result?.migrationConfirmed) {
              addLog(`Migration confirmed by n8n`, 'success');
            }
          } else {
            addLog(`Box migration webhook failed: ${webhookResult.error}`, 'warning');
          }

          newResults.boxFoldersToDelete.push({
            mergedRecordId: candidate.merged.record.id,
            mergedRecordName: candidate.merged.name,
            survivorRecordId: candidate.survivor.record.id,
            survivorRecordName: candidate.survivor.name,
            keepBoxFolderId: boxMigration.keepBoxFolderId,
            deleteBoxFolderId: boxMigration.deleteBoxFolderId,
            keepBoxUrl: boxMigration.keepBoxUrl,
            deleteBoxUrl: boxMigration.deleteBoxUrl,
            webhookSent: webhookResult.success,
            webhookResponse: webhookResult.result,
            webhookPayload: webhookResult.payload,
            migrationConfirmed: webhookResult.result?.migrationConfirmed || false
          });
        }

        // Build update payload
        const updateFields = {};
        Object.entries(fieldDecisions).forEach(([fieldName, decision]) => {
          if (decision.include && !schema.computedFields.includes(fieldName) && !EXCLUDE_FROM_MERGE.includes(fieldName)) {
            updateFields[fieldName] = decision.value;
          }
        });

        // Build history entry with box migration info
        const historyEntry = buildMergeHistoryEntry(candidate.survivor, candidate.merged, fieldDecisions, candidate, 'Bulk merge - auto-resolved', boxMigrationRecord);
        // Use append-only function to ensure we never lose existing history
        updateFields['dedupe_history'] = appendToDedupeHistory(survivorFields['dedupe_history'], historyEntry);

        // Perform the merge
        await client.updateRecord(credentials.tableName, candidate.survivor.record.id, updateFields);
        await client.deleteRecord(credentials.tableName, candidate.merged.record.id);

        newResults.success.push({
          candidate,
          historyEntry,
          boxMigrationRecord
        });

        addLog(`Merged: ${candidate.merged.name} -> ${candidate.survivor.name}`, 'success');

        // Small delay to avoid rate limiting
        await new Promise(r => setTimeout(r, 250));

      } catch (err) {
        newResults.failed.push({
          candidate,
          error: err.message
        });
        addLog(`Failed: ${candidate.merged.name} - ${err.message}`, 'error');
      }
    }

    setResults(newResults);
    setProgress({ current: selectedCandidates.length, total: selectedCandidates.length, status: 'complete' });
    setMerging(false);
  };

  const exportBoxFolders = () => {
    // Export as CSV with all reversibility info
    const csvHeaders = [
      'Merged Record ID',
      'Merged Record Name',
      'Survivor Record ID',
      'Survivor Record Name',
      'Keep Box Folder ID (Target)',
      'Delete Box Folder ID (Source)',
      'Keep Box Folder URL',
      'Delete Box Folder URL',
      'Webhook Sent',
      'Migration Confirmed',
      'n8n Renamed Folder Name',
      'Export Timestamp'
    ];

    const timestamp = new Date().toISOString();
    const csvRows = results.boxFoldersToDelete.map(item => {
      // Get the renamed folder name from n8n response if available
      const renamedFolderName = item.webhookResponse?.renamed_folders?.[0]?.new_name ||
                                item.webhookResponse?.new_folder_name ||
                                `DEDUP_${item.deleteBoxFolderId}`;
      return [
        item.mergedRecordId,
        `"${(item.mergedRecordName || '').replace(/"/g, '""')}"`,
        item.survivorRecordId,
        `"${(item.survivorRecordName || '').replace(/"/g, '""')}"`,
        item.keepBoxFolderId,
        item.deleteBoxFolderId,
        item.keepBoxUrl || '',
        item.deleteBoxUrl || '',
        item.webhookSent ? 'Yes' : 'No',
        item.migrationConfirmed ? 'Yes' : 'Pending',
        renamedFolderName,
        timestamp
      ].join(',');
    });

    const csvContent = [csvHeaders.join(','), ...csvRows].join('\n');

    // Also create a summary section as comments at the end
    const summary = [
      '',
      '# Summary',
      `# Total migrations: ${results.boxFoldersToDelete.length}`,
      `# Webhooks sent: ${results.boxFoldersToDelete.filter(x => x.webhookSent).length}`,
      `# Confirmed: ${results.boxFoldersToDelete.filter(x => x.migrationConfirmed).length}`,
      `# Export date: ${timestamp}`,
      '# ',
      '# To reverse a migration:',
      '# 1. Find the renamed folder in Box (DEDUP_xxx prefix)',
      '# 2. Move files back from target to source',
      '# 3. Use the Unmerge feature in the app to restore the Airtable record'
    ].join('\n');

    const blob = new Blob([csvContent + '\n' + summary], { type: 'text/csv' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `box-folder-migrations-${new Date().toISOString().slice(0, 10)}.csv`;
    a.click();
    URL.revokeObjectURL(url);
  };

  const progressPercent = progress.total > 0 ? Math.round((progress.current / progress.total) * 100) : 0;

  return (
    <div className="modal-overlay" onClick={onClose}>
      <div className="modal" onClick={e => e.stopPropagation()} style={{ maxWidth: '800px' }}>
        <div className="modal-header">
          <div>
            <h2>Bulk Merge</h2>
            <div style={{ color: '#94a3b8', marginTop: '5px' }}>
              {selectedCandidates.length} duplicate pairs selected
            </div>
          </div>
          <button className="modal-close" onClick={onClose}>&times;</button>
        </div>

        <div className="modal-body">
          {progress.status === 'pending' && (
            <>
              <div style={{ background: 'rgba(99, 102, 241, 0.1)', border: '1px solid rgba(99, 102, 241, 0.3)', borderRadius: '8px', padding: '20px', marginBottom: '20px' }}>
                <h3 style={{ margin: '0 0 15px 0', color: '#a5b4fc' }}>Auto-Resolution Rules</h3>
                <div style={{ fontSize: '0.9em', color: '#94a3b8', lineHeight: '1.6' }}>
                  <p>The following conflicts will be automatically resolved:</p>
                  <ul style={{ marginLeft: '20px', marginTop: '10px' }}>
                    <li><strong>Phone Numbers:</strong> Same number in different formats will be unified</li>
                    <li><strong>PPID/Clio ID:</strong> Survivor's ID will be kept</li>
                    <li><strong>Box Folders:</strong> Webhook sent to n8n to migrate files, then survivor's folder kept</li>
                    <li><strong>Middle Name/DOB:</strong> Survivor's value kept</li>
                    <li><strong>smsFolder:</strong> Survivor's folder kept</li>
                    <li><strong>Link Fields:</strong> Combined from both records</li>
                    <li><strong>Other Fields:</strong> Non-empty values preferred, then survivor's value</li>
                  </ul>
                </div>
              </div>

              <div style={{ background: 'rgba(245, 158, 11, 0.1)', border: '1px solid rgba(245, 158, 11, 0.3)', borderRadius: '8px', padding: '15px', marginBottom: '20px' }}>
                <strong style={{ color: '#f59e0b' }}>Note:</strong>
                <span style={{ color: '#94a3b8', marginLeft: '10px' }}>
                  Box folders from merged records will be listed for manual cleanup in Box.
                </span>
              </div>

              <div style={{ textAlign: 'center', padding: '20px' }}>
                <button className="primary" onClick={handleBulkMerge} style={{ fontSize: '1.1em', padding: '15px 40px' }}>
                  Start Bulk Merge ({selectedCandidates.length} pairs)
                </button>
              </div>
            </>
          )}

          {progress.status === 'running' && (
            <div style={{ textAlign: 'center', padding: '40px 20px' }}>
              <div style={{ fontSize: '1.2em', marginBottom: '20px' }}>
                Merging... {progress.current} of {progress.total}
              </div>
              <div className="progress-bar" style={{ height: '12px', borderRadius: '6px' }}>
                <div className="fill" style={{ width: `${progressPercent}%` }}></div>
              </div>
              <div style={{ color: '#94a3b8', marginTop: '15px' }}>
                Please wait, do not close this window...
              </div>
            </div>
          )}

          {progress.status === 'complete' && (
            <>
              <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr 1fr', gap: '15px', marginBottom: '20px' }}>
                <div className="stat-card" style={{ background: 'rgba(16, 185, 129, 0.1)', border: '1px solid rgba(16, 185, 129, 0.3)' }}>
                  <div className="number" style={{ color: '#10b981' }}>{results.success.length}</div>
                  <div className="label">Successfully Merged</div>
                </div>
                <div className="stat-card" style={{ background: 'rgba(239, 68, 68, 0.1)', border: '1px solid rgba(239, 68, 68, 0.3)' }}>
                  <div className="number" style={{ color: '#ef4444' }}>{results.failed.length}</div>
                  <div className="label">Failed</div>
                </div>
                <div className="stat-card" style={{ background: 'rgba(245, 158, 11, 0.1)', border: '1px solid rgba(245, 158, 11, 0.3)' }}>
                  <div className="number" style={{ color: '#f59e0b' }}>{results.boxFoldersToDelete.length}</div>
                  <div className="label">Box Migrations</div>
                </div>
              </div>

              {results.boxFoldersToDelete.length > 0 && (
                <div style={{ background: '#0f172a', borderRadius: '8px', padding: '15px', marginBottom: '20px' }}>
                  <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '15px' }}>
                    <h3 style={{ margin: 0, color: '#f59e0b' }}>Box Folder Migrations (Webhook Sent to n8n)</h3>
                    <button className="warning small" onClick={exportBoxFolders}>
                      Export CSV
                    </button>
                  </div>
                  <div style={{ maxHeight: '200px', overflow: 'auto' }}>
                    {results.boxFoldersToDelete.map((item, idx) => (
                      <div key={idx} style={{ padding: '10px', borderBottom: '1px solid #334155', fontSize: '0.85em' }}>
                        <div style={{ color: '#e2e8f0', marginBottom: '5px' }}>
                          <strong>{item.mergedRecordName}</strong> merged into {item.survivorRecordName}
                        </div>
                        <div style={{ color: '#94a3b8', marginLeft: '15px' }}>
                          Keep: <code style={{ background: 'rgba(16, 185, 129, 0.2)', padding: '2px 6px', borderRadius: '4px', color: '#10b981' }}>{item.keepBoxFolderId}</code>
                        </div>
                        <div style={{ color: '#94a3b8', marginLeft: '15px' }}>
                          Delete: <code style={{ background: 'rgba(239, 68, 68, 0.2)', padding: '2px 6px', borderRadius: '4px', color: '#ef4444' }}>{item.deleteBoxFolderId}</code>
                        </div>
                        <div style={{ marginLeft: '15px', marginTop: '5px' }}>
                          {item.webhookSent ? (
                            item.migrationConfirmed ? (
                              <span style={{ color: '#10b981', fontSize: '0.8em' }}>Migration confirmed by n8n</span>
                            ) : (
                              <span style={{ color: '#f59e0b', fontSize: '0.8em' }}>Webhook sent - awaiting confirmation</span>
                            )
                          ) : (
                            <span style={{ color: '#ef4444', fontSize: '0.8em' }}>Webhook failed</span>
                          )}
                        </div>
                      </div>
                    ))}
                  </div>
                </div>
              )}

              {results.failed.length > 0 && (
                <div style={{ background: 'rgba(239, 68, 68, 0.1)', borderRadius: '8px', padding: '15px', marginBottom: '20px' }}>
                  <h3 style={{ margin: '0 0 10px 0', color: '#ef4444' }}>Failed Merges</h3>
                  {results.failed.map((item, idx) => (
                    <div key={idx} style={{ padding: '8px', color: '#ef4444', fontSize: '0.85em' }}>
                      {item.candidate.merged.name}: {item.error}
                    </div>
                  ))}
                </div>
              )}
            </>
          )}
        </div>

        <div className="modal-footer">
          {progress.status === 'complete' ? (
            <button className="primary" onClick={() => onComplete(results)}>
              Done
            </button>
          ) : (
            <button className="secondary" onClick={onClose} disabled={merging}>
              Cancel
            </button>
          )}
        </div>
      </div>
    </div>
  );
}

// ============================================
// MAIN APP
// ============================================

function App() {
  const [accessLevel, setAccessLevel] = useState(() => sessionStorage.getItem('access_level') || null);
  const [selectedTable, setSelectedTable] = useState(() => sessionStorage.getItem('selected_table') || null);

  const handleLogin = (level) => {
    setAccessLevel(level);
    sessionStorage.setItem('access_level', level);
  };

  const handleSelectTable = (tableId) => {
    setSelectedTable(tableId);
    sessionStorage.setItem('selected_table', tableId);
  };

  const handleLogout = () => {
    setAccessLevel(null);
    setSelectedTable(null);
    sessionStorage.removeItem('access_level');
    sessionStorage.removeItem('selected_table');
  };

  const handleBackToTableSelect = () => {
    setSelectedTable(null);
    sessionStorage.removeItem('selected_table');
  };

  // Step 1: Login
  if (!accessLevel) return <LoginScreen onLogin={handleLogin} />;

  // Step 2: Table Selection
  if (!selectedTable) return <TableSelector onSelectTable={handleSelectTable} onBack={handleLogout} />;

  // Step 3: Main App with selected table
  const tableConfig = TABLE_CONFIGS[selectedTable];
  return (
    <MainApp
      accessLevel={accessLevel}
      tableConfig={tableConfig}
      onLogout={handleLogout}
      onSwitchTable={handleBackToTableSelect}
    />
  );
}

function MainApp({ accessLevel, tableConfig, onLogout, onSwitchTable }) {
  const [apiKey, setApiKey] = useState(() => localStorage.getItem('airtable_api_key') || '');
  const [baseId, setBaseId] = useState(AIRTABLE_BASE_ID);
  const [loading, setLoading] = useState(false);
  const [scanning, setScanning] = useState(false);
  const [logs, setLogs] = useState([]);
  const [schema, setSchema] = useState(null);
  const [allRecords, setAllRecords] = useState([]);
  const [candidates, setCandidates] = useState([]);
  const [selectedCandidate, setSelectedCandidate] = useState(null);
  const [activeTab, setActiveTab] = useState('scan');
  const [tierFilter, setTierFilter] = useState('all');
  const [searchFilter, setSearchFilter] = useState('');
  const [bahrFilter, setBahrFilter] = useState('all');
  const [createdDateFrom, setCreatedDateFrom] = useState('');
  const [createdDateTo, setCreatedDateTo] = useState('');
  // Selection state for bulk operations
  const [selectedIds, setSelectedIds] = useState(new Set());
  const [lastSelectedIndex, setLastSelectedIndex] = useState(null);
  const [showBulkMergeModal, setShowBulkMergeModal] = useState(false);

  // Table-specific values
  const tableName = tableConfig.tableId;
  const hasBahrFilter = tableConfig.hasBahrFilter;

  // Match configuration state with localStorage persistence (per-table)
  const configStorageKey = `dedupe_match_config_${tableConfig.id}`;
  const [matchConfig, setMatchConfig] = useState(() => {
    try {
      const saved = localStorage.getItem(configStorageKey);
      if (saved) {
        const parsed = JSON.parse(saved);
        // Merge saved config with defaults to handle any new fields
        return {
          ...DEFAULT_MATCH_CONFIG,
          ...parsed,
          fields: { ...DEFAULT_MATCH_CONFIG.fields, ...parsed.fields },
        };
      }
    } catch (e) {
      console.warn('Failed to load match config from localStorage:', e);
    }
    return DEFAULT_MATCH_CONFIG;
  });

  const logRef = useRef(null);
  const isBahrOnly = accessLevel === 'bahr' && hasBahrFilter;
  const credentials = { apiKey, baseId, tableName, tableConfig };

  useEffect(() => { if (apiKey) localStorage.setItem('airtable_api_key', apiKey); }, [apiKey]);
  useEffect(() => { if (logRef.current) logRef.current.scrollTop = logRef.current.scrollHeight; }, [logs]);

  // Persist match config to localStorage (per-table)
  useEffect(() => {
    localStorage.setItem(configStorageKey, JSON.stringify(matchConfig));
  }, [matchConfig, configStorageKey]);

  const addLog = useCallback((message, type = 'info') => {
    setLogs(prev => [...prev, { message, type, timestamp: new Date().toLocaleTimeString() }]);
  }, []);

  // Re-scan existing records with current match config (no re-fetch)
  const rescanWithConfig = useCallback(() => {
    if (allRecords.length === 0) {
      addLog('No records loaded. Please fetch records first.', 'error');
      return;
    }

    setScanning(true);
    addLog(`Re-scanning ${allRecords.length} records with updated match settings...`, 'info');

    // Use setTimeout to allow UI to update before processing
    setTimeout(() => {
      try {
        const dupes = findDuplicateCandidates(allRecords, (p) => {
          if (p.current % 100 === 0) addLog(`Matching: ${p.current}/${p.total} groups`, 'info');
        }, matchConfig);

        setCandidates(dupes);
        setSelectedIds(new Set()); // Clear selection on re-scan

        const byTier = { 1: 0, 2: 0, 3: 0, 4: 0 };
        dupes.forEach(c => byTier[c.tier.tier]++);
        addLog(`Found ${dupes.length} duplicate pairs`, dupes.length > 0 ? 'warning' : 'success');
        addLog(`  Tier 1 (Definitive): ${byTier[1]}`, 'info');
        addLog(`  Tier 2 (Strong): ${byTier[2]}`, 'info');
        addLog(`  Tier 3 (Possible): ${byTier[3]}`, 'info');
        addLog(`  Tier 4 (Conflicts): ${byTier[4]}`, byTier[4] > 0 ? 'error' : 'info');
      } catch (err) {
        addLog(`Error during re-scan: ${err.message}`, 'error');
      } finally {
        setScanning(false);
      }
    }, 50);
  }, [allRecords, matchConfig, addLog]);

  const fetchAndScan = async () => {
    if (!apiKey) { addLog('Please enter API key', 'error'); return; }
    setLoading(true);
    setLogs([]);
    setAllRecords([]); // Clear records while fetching
    setCandidates([]); // Clear candidates while fetching
    try {
      const client = new AirtableClient(apiKey, baseId);

      addLog(`Fetching schema for ${tableConfig.name}...`, 'info');
      const tableSchema = await client.getTableSchema(tableName);
      setSchema(tableSchema);
      addLog(`Schema: ${tableSchema.writableFields.length} writable, ${tableSchema.computedFields.length} computed fields`, 'success');

      const filter = isBahrOnly ? '{Bahr Client}' : '';
      addLog(`Fetching ${isBahrOnly ? 'Bahr clients' : 'all records'}...`, 'info');

      // Include history field and Created for filtering
      const historyField = tableConfig.historyField || 'dedupe_history';
      const fieldsToFetch = [...tableSchema.writableFields, historyField, 'Created'].filter((f, i, arr) => arr.indexOf(f) === i);

      // Stream records as they load - update state incrementally
      let allFetchedRecords = [];
      const records = await client.getAllRecords(tableName, fieldsToFetch, filter,
        (p) => {
          addLog(`Page ${p.page}: ${p.total} records loaded`, 'info');
          // Update allRecords incrementally to show progress
          if (p.records) {
            allFetchedRecords = [...allFetchedRecords, ...p.records];
            setAllRecords([...allFetchedRecords]);
          }
        });

      // Final update with all records
      setAllRecords(records);
      addLog(`Fetched ${records.length} records total`, 'success');

      addLog('Analyzing for duplicates...', 'info');
      const dupes = findDuplicateCandidates(records, (p) => {
        if (p.current % 100 === 0) addLog(`Matching: ${p.current}/${p.total} groups`, 'info');
      }, matchConfig);
      setCandidates(dupes);

      const byTier = { 1: 0, 2: 0, 3: 0, 4: 0 };
      dupes.forEach(c => byTier[c.tier.tier]++);
      addLog(`Found ${dupes.length} duplicate pairs`, dupes.length > 0 ? 'warning' : 'success');
      addLog(`  Tier 1 (Definitive): ${byTier[1]}`, 'info');
      addLog(`  Tier 2 (Strong): ${byTier[2]}`, 'info');
      addLog(`  Tier 3 (Possible): ${byTier[3]}`, 'info');
      addLog(`  Tier 4 (Conflicts): ${byTier[4]}`, byTier[4] > 0 ? 'error' : 'info');
    } catch (err) {
      addLog(`Error: ${err.message}`, 'error');
    } finally {
      setLoading(false);
    }
  };

  const handleMergeComplete = (historyEntry) => {
    addLog(`Merge ${historyEntry.merge_id} completed!`, 'success');
    setSelectedCandidate(null);
    setCandidates(prev => prev.filter(c => c.id !== selectedCandidate.id));
  };

  // Handle row selection with shift-click support
  const handleRowSelect = (candidate, index, event) => {
    event.stopPropagation();

    if (event.shiftKey && lastSelectedIndex !== null) {
      // Shift-click: select range
      const start = Math.min(lastSelectedIndex, index);
      const end = Math.max(lastSelectedIndex, index);
      const newSelected = new Set(selectedIds);

      for (let i = start; i <= end; i++) {
        newSelected.add(filteredCandidates[i].id);
      }
      setSelectedIds(newSelected);
    } else if (event.ctrlKey || event.metaKey) {
      // Ctrl/Cmd-click: toggle single
      const newSelected = new Set(selectedIds);
      if (newSelected.has(candidate.id)) {
        newSelected.delete(candidate.id);
      } else {
        newSelected.add(candidate.id);
      }
      setSelectedIds(newSelected);
      setLastSelectedIndex(index);
    } else {
      // Regular click: toggle single and set as last selected
      const newSelected = new Set(selectedIds);
      if (newSelected.has(candidate.id)) {
        newSelected.delete(candidate.id);
      } else {
        newSelected.add(candidate.id);
      }
      setSelectedIds(newSelected);
      setLastSelectedIndex(index);
    }
  };

  const filteredCandidates = useMemo(() => {
    let result = [...candidates];
    if (tierFilter !== 'all') result = result.filter(c => c.tier.tier === parseInt(tierFilter));
    if (bahrFilter !== 'all') {
      const isBahr = bahrFilter === 'yes';
      result = result.filter(c => {
        const hasBahr = c.survivor.record.fields['Bahr Client'] || c.merged.record.fields['Bahr Client'];
        return isBahr ? hasBahr : !hasBahr;
      });
    }
    if (searchFilter.trim()) {
      const q = searchFilter.toLowerCase();
      result = result.filter(c =>
        c.survivor.name.toLowerCase().includes(q) ||
        c.merged.name.toLowerCase().includes(q) ||
        c.survivor.record.id.includes(q) ||
        c.merged.record.id.includes(q)
      );
    }
    // Filter by Created date
    if (createdDateFrom || createdDateTo) {
      result = result.filter(c => {
        const survivorCreated = c.survivor.record.fields['Created'] || c.survivor.record.fields['createdTime'];
        const mergedCreated = c.merged.record.fields['Created'] || c.merged.record.fields['createdTime'];
        // Use the earliest created date between the two records
        const createdDate = survivorCreated || mergedCreated;
        if (!createdDate) return true; // Include if no date

        const recordDate = new Date(createdDate).toISOString().split('T')[0];
        if (createdDateFrom && recordDate < createdDateFrom) return false;
        if (createdDateTo && recordDate > createdDateTo) return false;
        return true;
      });
    }
    return result;
  }, [candidates, tierFilter, bahrFilter, searchFilter, createdDateFrom, createdDateTo]);

  // Select all visible candidates
  const handleSelectAll = () => {
    if (selectedIds.size === filteredCandidates.length) {
      setSelectedIds(new Set());
    } else {
      setSelectedIds(new Set(filteredCandidates.map(c => c.id)));
    }
  };

  // Get selected candidates for bulk merge
  const selectedCandidates = useMemo(() =>
    filteredCandidates.filter(c => selectedIds.has(c.id)),
    [filteredCandidates, selectedIds]
  );

  // Handle bulk merge completion
  const handleBulkMergeComplete = (results) => {
    const mergedIds = results.success.map(r => r.candidate.id);
    setCandidates(prev => prev.filter(c => !mergedIds.includes(c.id)));
    setSelectedIds(new Set());
    setShowBulkMergeModal(false);
    addLog(`Bulk merge complete: ${results.success.length} merged, ${results.failed.length} failed`, 'success');
    if (results.boxFoldersToDelete.length > 0) {
      addLog(`${results.boxFoldersToDelete.length} box folders flagged for deletion`, 'warning');
    }
  };

  const stats = useMemo(() => ({
    total: allRecords.length,
    candidates: candidates.length,
    byTier: { 1: candidates.filter(c => c.tier.tier === 1).length, 2: candidates.filter(c => c.tier.tier === 2).length,
              3: candidates.filter(c => c.tier.tier === 3).length, 4: candidates.filter(c => c.tier.tier === 4).length }
  }), [allRecords, candidates]);

  return (
    <div className="container">
      <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'flex-start', flexWrap: 'wrap', gap: '10px', marginBottom: '20px' }}>
        <div>
          <h1 style={{ display: 'flex', alignItems: 'center', gap: '12px' }}>
            <span style={{ fontSize: '1.2em' }}>{tableConfig.icon}</span>
            Airtable Dedupe
          </h1>
          <p className="subtitle" style={{ display: 'flex', alignItems: 'center', gap: '10px' }}>
            <span style={{
              background: 'rgba(99, 102, 241, 0.2)',
              color: '#a5b4fc',
              padding: '3px 10px',
              borderRadius: '4px',
              fontSize: '0.9em',
            }}>
              {tableConfig.name}
            </span>
            Deduplication with Tiered Matching
          </p>
        </div>
        <div style={{ display: 'flex', alignItems: 'center', gap: '10px', flexWrap: 'wrap' }}>
          {hasBahrFilter && (
            <span style={{ background: isBahrOnly ? '#6366f1' : '#10b981', color: 'white', padding: '6px 12px', borderRadius: '6px', fontSize: '0.85em' }}>
              {isBahrOnly ? 'Bahr Clients' : 'All Clients'}
            </span>
          )}
          {tableConfig.flatpackField && (
            <span style={{
              background: 'rgba(168, 85, 247, 0.2)',
              color: '#a855f7',
              padding: '6px 12px',
              borderRadius: '6px',
              fontSize: '0.85em',
            }}>
              {tableConfig.flatpackField}
            </span>
          )}
          <button onClick={onSwitchTable} className="secondary small">Switch Table</button>
          <button onClick={onLogout} className="secondary small">Logout</button>
        </div>
      </div>

      <div className="tabs">
        <div className={`tab ${activeTab === 'scan' ? 'active' : ''}`} onClick={() => setActiveTab('scan')}>
          Scan & Review ({candidates.length})
        </div>
        <div className={`tab ${activeTab === 'history' ? 'active' : ''}`} onClick={() => setActiveTab('history')}>
          History
        </div>
      </div>

      {activeTab === 'scan' && (
        <>
          <div className="card">
            <h2>Airtable Connection</h2>
            <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '15px' }}>
              <div className="input-group">
                <label>API Key (Personal Access Token)</label>
                <input type="password" value={apiKey} onChange={e => setApiKey(e.target.value)} placeholder="pat_..." />
              </div>
              <div className="input-group">
                <label>Base ID</label>
                <input type="text" value={baseId} onChange={e => setBaseId(e.target.value)} placeholder="app..." />
              </div>
            </div>
            <div className="btn-group">
              <button className="primary" onClick={fetchAndScan} disabled={loading || !apiKey}>
                {loading ? 'Scanning...' : 'Fetch & Scan for Duplicates'}
              </button>
            </div>
          </div>

          {/* Show stats when records are loaded */}
          {allRecords.length > 0 && (
            <div className="stats-grid">
              <div className="stat-card"><div className="number">{stats.total}</div><div className="label">Total Records</div></div>
              <div className="stat-card tier1"><div className="number">{stats.byTier[1]}</div><div className="label">Tier 1 Definitive</div></div>
              <div className="stat-card tier2"><div className="number">{stats.byTier[2]}</div><div className="label">Tier 2 Strong</div></div>
              <div className="stat-card tier3"><div className="number">{stats.byTier[3]}</div><div className="label">Tier 3 Possible</div></div>
              <div className="stat-card tier4"><div className="number">{stats.byTier[4]}</div><div className="label">Tier 4 Conflicts</div></div>
            </div>
          )}

          {/* Match Settings Panel - show after records are loaded */}
          {allRecords.length > 0 && (
            <MatchSettingsPanel
              config={matchConfig}
              onChange={setMatchConfig}
              onRescan={rescanWithConfig}
              allRecords={allRecords}
              schema={schema}
              disabled={loading || scanning}
            />
          )}

          {candidates.length > 0 && (
            <div className="card">
              <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: '15px' }}>
                <h2 style={{ margin: 0 }}>Duplicate Candidates ({filteredCandidates.length})</h2>
                {selectedIds.size > 0 && (
                  <div style={{ display: 'flex', alignItems: 'center', gap: '15px' }}>
                    <span style={{ color: '#a5b4fc' }}>
                      {selectedIds.size} selected
                    </span>
                    <button
                      className="success"
                      onClick={() => setShowBulkMergeModal(true)}
                      disabled={!schema}
                    >
                      Bulk Merge Selected
                    </button>
                    <button
                      className="secondary small"
                      onClick={() => setSelectedIds(new Set())}
                    >
                      Clear Selection
                    </button>
                  </div>
                )}
              </div>

              {/* Filter Controls */}
              <div className="filter-controls" style={{ marginBottom: '10px' }}>
                <select value={tierFilter} onChange={e => setTierFilter(e.target.value)}>
                  <option value="all">All Tiers</option>
                  <option value="1">Tier 1 - Definitive</option>
                  <option value="2">Tier 2 - Strong</option>
                  <option value="3">Tier 3 - Possible</option>
                  <option value="4">Tier 4 - Conflicts</option>
                </select>
                {hasBahrFilter && (
                  <select value={bahrFilter} onChange={e => setBahrFilter(e.target.value)}>
                    <option value="all">All Clients</option>
                    <option value="yes">Bahr Client = T Only</option>
                    <option value="no">Non-Bahr Clients Only</option>
                  </select>
                )}
                <input type="text" value={searchFilter} onChange={e => setSearchFilter(e.target.value)} placeholder="Search by name or ID..." />
              </div>

              {/* Date Filter */}
              <div className="filter-controls" style={{ marginBottom: '15px' }}>
                <div style={{ display: 'flex', alignItems: 'center', gap: '8px' }}>
                  <label style={{ color: '#94a3b8', fontSize: '0.9em', whiteSpace: 'nowrap' }}>Created From:</label>
                  <input
                    type="date"
                    value={createdDateFrom}
                    onChange={e => setCreatedDateFrom(e.target.value)}
                    style={{ width: 'auto', minWidth: '140px' }}
                  />
                </div>
                <div style={{ display: 'flex', alignItems: 'center', gap: '8px' }}>
                  <label style={{ color: '#94a3b8', fontSize: '0.9em', whiteSpace: 'nowrap' }}>To:</label>
                  <input
                    type="date"
                    value={createdDateTo}
                    onChange={e => setCreatedDateTo(e.target.value)}
                    style={{ width: 'auto', minWidth: '140px' }}
                  />
                </div>
                {(createdDateFrom || createdDateTo) && (
                  <button
                    className="secondary small"
                    onClick={() => { setCreatedDateFrom(''); setCreatedDateTo(''); }}
                  >
                    Clear Dates
                  </button>
                )}
              </div>

              <div style={{ fontSize: '0.85em', color: '#94a3b8', marginBottom: '10px' }}>
                Tip: Click checkbox to select, Shift+click to select range, Ctrl/Cmd+click to toggle
              </div>
              <div className="table-container">
                <table>
                  <thead>
                    <tr>
                      <th style={{ width: '40px' }}>
                        <input
                          type="checkbox"
                          checked={filteredCandidates.length > 0 && selectedIds.size === filteredCandidates.length}
                          onChange={handleSelectAll}
                          style={{ width: '18px', height: '18px', cursor: 'pointer' }}
                          title="Select all"
                        />
                      </th>
                      <th>Confidence</th>
                      <th>Bahr Client</th>
                      <th>Created</th>
                      <th>Keep (Record A)</th>
                      <th>Merge (Record B)</th>
                      <th>Match Reasons</th>
                      <th>Action</th>
                    </tr>
                  </thead>
                  <tbody>
                    {filteredCandidates.map((c, idx) => {
                      const survivorCreated = c.survivor.record.fields['Created'] || c.survivor.record.fields['createdTime'];
                      const mergedCreated = c.merged.record.fields['Created'] || c.merged.record.fields['createdTime'];
                      const displayDate = survivorCreated || mergedCreated;
                      const isTier4 = c.tier.tier === 4;

                      return (
                        <tr
                          key={c.id}
                          className="clickable"
                          style={{
                            background: selectedIds.has(c.id) ? 'rgba(99, 102, 241, 0.2)' : undefined
                          }}
                        >
                          <td onClick={e => e.stopPropagation()}>
                            <input
                              type="checkbox"
                              checked={selectedIds.has(c.id)}
                              onChange={(e) => handleRowSelect(c, idx, e)}
                              onClick={(e) => handleRowSelect(c, idx, e)}
                              disabled={isTier4}
                              style={{ width: '18px', height: '18px', cursor: 'pointer' }}
                              title={isTier4 ? "Tier 4 conflicts must be reviewed individually" : "Select for bulk merge"}
                            />
                          </td>
                          <td onClick={() => setSelectedCandidate(c)}>
                            <span className={`badge tier${c.tier.tier}`}>{c.confidence}%</span>
                            <div style={{ fontSize: '0.75em', color: '#94a3b8' }}>{c.tier.name}</div>
                          </td>
                          <td onClick={() => setSelectedCandidate(c)}>
                            {(c.survivor.record.fields['Bahr Client'] || c.merged.record.fields['Bahr Client']) ? (
                              <span style={{ background: '#6366f1', color: 'white', padding: '2px 8px', borderRadius: '4px', fontSize: '0.8em' }}>Yes</span>
                            ) : (
                              <span style={{ color: '#64748b', fontSize: '0.8em' }}>No</span>
                            )}
                          </td>
                          <td onClick={() => setSelectedCandidate(c)}>
                            {displayDate ? (
                              <span style={{ fontSize: '0.8em', color: '#94a3b8' }}>
                                {new Date(displayDate).toLocaleDateString()}
                              </span>
                            ) : (
                              <span style={{ color: '#64748b', fontSize: '0.8em' }}>-</span>
                            )}
                          </td>
                          <td onClick={() => setSelectedCandidate(c)}>
                            <div style={{ fontWeight: '500' }}>{c.survivor.name}</div>
                            <div style={{ fontSize: '0.75em', color: '#94a3b8' }}>Score: {c.survivor.score}</div>
                          </td>
                          <td onClick={() => setSelectedCandidate(c)}>
                            <div>{c.merged.name}</div>
                            <div style={{ fontSize: '0.75em', color: '#94a3b8' }}>Score: {c.merged.score}</div>
                          </td>
                          <td onClick={() => setSelectedCandidate(c)}>
                            {c.reasons.slice(0, 2).map((r, i) => <span key={i} className="reason-tag">{r}</span>)}
                            {c.reasons.length > 2 && <span className="reason-tag">+{c.reasons.length - 2}</span>}
                            {c.conflicts?.map((cf, i) => <span key={i} className="reason-tag conflict">{cf}</span>)}
                          </td>
                          <td><button className="primary small" onClick={() => setSelectedCandidate(c)}>Review</button></td>
                        </tr>
                      );
                    })}
                  </tbody>
                </table>
              </div>
            </div>
          )}

          {allRecords.length > 0 && candidates.length === 0 && (
            <div className="card" style={{ textAlign: 'center' }}>
              <h2 style={{ color: '#10b981' }}>No Duplicates Found</h2>
              <p>All {allRecords.length} records appear to be unique.</p>
            </div>
          )}
        </>
      )}

      {activeTab === 'history' && <HistoryViewer credentials={credentials} addLog={addLog} />}

      <div className="card">
        <h2>Activity Log</h2>
        <div className="log-container" ref={logRef}>
          {logs.length === 0 ? (
            <div className="log-entry info">Ready - configure connection and click Scan</div>
          ) : (
            logs.map((log, idx) => (
              <div key={idx} className={`log-entry ${log.type}`}>[{log.timestamp}] {log.message}</div>
            ))
          )}
        </div>
        {logs.length > 0 && <button className="warning small" onClick={() => setLogs([])} style={{ marginTop: '10px' }}>Clear</button>}
      </div>

      {selectedCandidate && (
        <MergeReviewModal
          candidate={selectedCandidate}
          schema={schema}
          credentials={credentials}
          onComplete={handleMergeComplete}
          onSkip={() => { setCandidates(prev => prev.filter(c => c.id !== selectedCandidate.id)); setSelectedCandidate(null); }}
          onClose={() => setSelectedCandidate(null)}
          addLog={addLog}
        />
      )}

      {showBulkMergeModal && selectedCandidates.length > 0 && (
        <BulkMergeModal
          selectedCandidates={selectedCandidates}
          schema={schema}
          credentials={credentials}
          onComplete={handleBulkMergeComplete}
          onClose={() => setShowBulkMergeModal(false)}
          addLog={addLog}
        />
      )}
    </div>
  );
}

ReactDOM.createRoot(document.getElementById('root')).render(<App />);
  </script>
</body>
</html>
