<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Airtable Dedupe - Client Deduplication Tool</title>
  <script src="https://unpkg.com/react@18/umd/react.production.min.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js" crossorigin></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/fuse.js@7.0.0"></script>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
      min-height: 100vh;
      color: #e2e8f0;
    }
    .container { max-width: 1600px; margin: 0 auto; padding: 20px; }
    h1 { color: #a5b4fc; margin-bottom: 10px; }
    .subtitle { color: #94a3b8; margin-bottom: 20px; }

    .card {
      background: rgba(30, 41, 59, 0.8);
      border: 1px solid #334155;
      border-radius: 12px;
      padding: 20px;
      margin-bottom: 20px;
    }
    .card h2 { color: #a5b4fc; margin-bottom: 15px; font-size: 1.2em; }
    .card h3 { color: #94a3b8; margin-bottom: 10px; font-size: 1em; }

    .input-group { margin-bottom: 15px; }
    .input-group label { display: block; margin-bottom: 5px; color: #94a3b8; }
    input[type="text"], input[type="password"], select, textarea {
      width: 100%;
      padding: 10px;
      border: 1px solid #475569;
      border-radius: 6px;
      background: #1e293b;
      color: #e2e8f0;
    }
    input:focus, select:focus, textarea:focus { outline: none; border-color: #6366f1; }

    button {
      padding: 10px 20px;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 0.9em;
      transition: all 0.2s;
    }
    button.primary { background: #6366f1; color: white; }
    button.primary:hover { background: #4f46e5; }
    button.success { background: #10b981; color: white; }
    button.success:hover { background: #059669; }
    button.warning { background: #f59e0b; color: white; }
    button.warning:hover { background: #d97706; }
    button.danger { background: #ef4444; color: white; }
    button.danger:hover { background: #dc2626; }
    button.secondary { background: #475569; color: white; }
    button.secondary:hover { background: #64748b; }
    button:disabled { background: #475569; cursor: not-allowed; opacity: 0.6; }
    button.small { padding: 6px 12px; font-size: 0.8em; }

    .btn-group { display: flex; gap: 10px; flex-wrap: wrap; margin-top: 15px; }

    .stats-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
      gap: 15px;
      margin: 15px 0;
    }
    .stat-card {
      background: #1e293b;
      border: 1px solid #334155;
      border-radius: 8px;
      padding: 15px;
      text-align: center;
    }
    .stat-card .number { font-size: 1.8em; font-weight: bold; color: #10b981; }
    .stat-card .label { color: #94a3b8; font-size: 0.85em; }
    .stat-card.tier1 .number { color: #10b981; }
    .stat-card.tier2 .number { color: #6366f1; }
    .stat-card.tier3 .number { color: #f59e0b; }
    .stat-card.tier4 .number { color: #ef4444; }

    .table-container { overflow-x: auto; margin: 15px 0; max-height: 500px; overflow-y: auto; }
    table { width: 100%; border-collapse: collapse; font-size: 0.85em; }
    th, td { padding: 10px; text-align: left; border-bottom: 1px solid #334155; }
    th { background: #1e293b; position: sticky; top: 0; color: #a5b4fc; z-index: 10; }
    tr:hover { background: rgba(99, 102, 241, 0.1); }
    tr.clickable { cursor: pointer; }
    tr.clickable:hover { background: rgba(99, 102, 241, 0.2); }

    .badge {
      display: inline-block;
      padding: 2px 8px;
      border-radius: 4px;
      font-size: 0.8em;
      font-weight: 500;
    }
    .badge.tier1 { background: #10b981; color: white; }
    .badge.tier2 { background: #6366f1; color: white; }
    .badge.tier3 { background: #f59e0b; color: white; }
    .badge.tier4 { background: #ef4444; color: white; }
    .badge.keep { background: #10b981; color: white; }
    .badge.merge { background: #f59e0b; color: white; }

    .log-container {
      background: #0f172a;
      border: 1px solid #334155;
      border-radius: 8px;
      padding: 15px;
      max-height: 250px;
      overflow-y: auto;
      font-family: monospace;
      font-size: 0.8em;
    }
    .log-entry { padding: 3px 0; border-bottom: 1px solid #1e293b; }
    .log-entry.info { color: #6366f1; }
    .log-entry.success { color: #10b981; }
    .log-entry.warning { color: #f59e0b; }
    .log-entry.error { color: #ef4444; }

    .progress-bar {
      background: #1e293b;
      border-radius: 4px;
      height: 8px;
      overflow: hidden;
      margin: 10px 0;
    }
    .progress-bar .fill {
      height: 100%;
      background: linear-gradient(90deg, #6366f1, #10b981);
      transition: width 0.3s;
    }

    .tabs { display: flex; gap: 5px; margin-bottom: 15px; flex-wrap: wrap; }
    .tab {
      padding: 10px 20px;
      background: #1e293b;
      border: 1px solid #334155;
      border-radius: 6px 6px 0 0;
      cursor: pointer;
      color: #94a3b8;
    }
    .tab.active { background: #334155; color: #a5b4fc; border-bottom-color: #334155; }

    .filter-controls {
      display: flex;
      gap: 15px;
      flex-wrap: wrap;
      margin-bottom: 15px;
      align-items: center;
    }
    .filter-controls select {
      width: auto;
      min-width: 150px;
    }
    .filter-controls input[type="text"] {
      width: auto;
      min-width: 200px;
    }

    .checkbox-label {
      display: flex;
      align-items: center;
      gap: 8px;
      cursor: pointer;
      color: #94a3b8;
    }
    .checkbox-label input { width: 18px; height: 18px; }

    /* Match reasons */
    .reason-tag {
      display: inline-block;
      background: #1e293b;
      padding: 2px 8px;
      border-radius: 4px;
      font-size: 0.75em;
      color: #94a3b8;
      margin: 2px;
    }
    .reason-tag.conflict {
      background: rgba(239, 68, 68, 0.2);
      border: 1px solid #ef4444;
      color: #ef4444;
    }

    /* Diff View */
    .diff-container {
      display: grid;
      grid-template-columns: 200px 1fr 1fr 150px;
      gap: 1px;
      background: #334155;
      border-radius: 8px;
      overflow: hidden;
      margin: 15px 0;
    }
    .diff-header {
      background: #1e293b;
      padding: 12px;
      font-weight: bold;
      color: #a5b4fc;
    }
    .diff-row {
      display: contents;
    }
    .diff-row:hover > div { background: rgba(99, 102, 241, 0.1); }
    .diff-cell {
      background: rgba(30, 41, 59, 0.9);
      padding: 10px;
      border-bottom: 1px solid #334155;
      font-size: 0.85em;
      word-break: break-word;
    }
    .diff-cell.field-name {
      font-weight: 500;
      color: #94a3b8;
    }
    .diff-cell.computed {
      opacity: 0.5;
      font-style: italic;
    }
    .diff-cell.different { background: rgba(245, 158, 11, 0.1); }
    .diff-cell.same { background: rgba(16, 185, 129, 0.05); }
    .diff-cell.selected { background: rgba(99, 102, 241, 0.2); border: 2px solid #6366f1; }
    .diff-cell.clickable { cursor: pointer; }
    .diff-cell.clickable:hover { background: rgba(99, 102, 241, 0.15); }
    .empty-value { color: #64748b; font-style: italic; }

    .pick-buttons {
      display: flex;
      gap: 5px;
    }
    .pick-btn {
      padding: 4px 10px;
      border: 1px solid #475569;
      background: #1e293b;
      color: #94a3b8;
      border-radius: 4px;
      cursor: pointer;
      font-size: 0.8em;
    }
    .pick-btn:hover { background: #334155; }
    .pick-btn.active { background: #6366f1; border-color: #6366f1; color: white; }
    .pick-btn.auto { background: #0f172a; color: #64748b; cursor: default; }

    /* Modal */
    .modal-overlay {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: rgba(0, 0, 0, 0.8);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 1000;
    }
    .modal {
      background: #1e293b;
      border: 1px solid #475569;
      border-radius: 12px;
      width: 90%;
      max-width: 1200px;
      max-height: 90vh;
      overflow: hidden;
      display: flex;
      flex-direction: column;
    }
    .modal-header {
      padding: 20px;
      border-bottom: 1px solid #334155;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .modal-header h2 { margin: 0; }
    .modal-close {
      background: none;
      border: none;
      color: #94a3b8;
      font-size: 1.5em;
      cursor: pointer;
      padding: 5px 10px;
    }
    .modal-close:hover { color: #e2e8f0; }
    .modal-body {
      padding: 20px;
      overflow-y: auto;
      flex: 1;
    }
    .modal-footer {
      padding: 15px 20px;
      border-top: 1px solid #334155;
      display: flex;
      justify-content: flex-end;
      gap: 10px;
    }

    /* Confidence meter */
    .confidence-meter {
      display: flex;
      align-items: center;
      gap: 10px;
    }
    .confidence-bar {
      flex: 1;
      height: 8px;
      background: #0f172a;
      border-radius: 4px;
      overflow: hidden;
    }
    .confidence-fill {
      height: 100%;
      border-radius: 4px;
    }
    .confidence-fill.tier1 { background: #10b981; }
    .confidence-fill.tier2 { background: #6366f1; }
    .confidence-fill.tier3 { background: #f59e0b; }
    .confidence-fill.tier4 { background: #ef4444; }

    /* History */
    .history-event {
      background: #0f172a;
      border: 1px solid #334155;
      border-radius: 12px;
      margin-bottom: 15px;
      overflow: hidden;
    }
    .history-event-header {
      padding: 15px 20px;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 15px;
    }
    .history-event-header:hover { background: #1e293b; }
    .history-event.merge { border-left: 4px solid #6366f1; }
    .history-event.unmerge { border-left: 4px solid #f59e0b; }
    .history-event-body {
      padding: 20px;
      border-top: 1px solid #334155;
      background: #1e293b;
    }
    .history-event-body pre {
      background: #0f172a;
      padding: 10px;
      border-radius: 6px;
      overflow-x: auto;
      font-size: 0.8em;
      max-height: 200px;
      overflow-y: auto;
    }

    /* Enhanced History Styles */
    .history-summary {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 15px;
      margin-bottom: 20px;
    }
    .history-summary-item {
      background: rgba(99, 102, 241, 0.1);
      border: 1px solid rgba(99, 102, 241, 0.3);
      border-radius: 8px;
      padding: 15px;
    }
    .history-summary-item .label {
      font-size: 0.75em;
      color: #94a3b8;
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: 5px;
    }
    .history-summary-item .value {
      font-size: 1.1em;
      color: #e2e8f0;
      font-weight: 500;
    }
    .merged-record-card {
      background: rgba(245, 158, 11, 0.1);
      border: 1px solid rgba(245, 158, 11, 0.3);
      border-radius: 8px;
      padding: 15px;
      margin-bottom: 15px;
    }
    .merged-record-card h4 {
      color: #f59e0b;
      margin-bottom: 10px;
      font-size: 0.9em;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .field-changes-table {
      width: 100%;
      border-collapse: collapse;
      font-size: 0.85em;
      margin-top: 10px;
    }
    .field-changes-table th {
      text-align: left;
      padding: 8px 10px;
      background: rgba(30, 41, 59, 0.5);
      color: #94a3b8;
      font-weight: 500;
      border-bottom: 1px solid #334155;
    }
    .field-changes-table td {
      padding: 8px 10px;
      border-bottom: 1px solid #1e293b;
      word-break: break-word;
    }
    .field-changes-table tr:hover td {
      background: rgba(99, 102, 241, 0.05);
    }
    .history-icon {
      width: 40px;
      height: 40px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.3em;
      flex-shrink: 0;
    }
    .history-icon.merge-icon {
      background: rgba(99, 102, 241, 0.2);
    }
    .history-icon.unmerge-icon {
      background: rgba(245, 158, 11, 0.2);
    }
    .history-tabs {
      display: flex;
      gap: 5px;
      margin-bottom: 15px;
      border-bottom: 1px solid #334155;
      padding-bottom: 10px;
    }
    .history-tab {
      padding: 8px 16px;
      background: transparent;
      border: none;
      color: #94a3b8;
      cursor: pointer;
      border-radius: 6px 6px 0 0;
      font-size: 0.85em;
    }
    .history-tab:hover {
      background: rgba(99, 102, 241, 0.1);
    }
    .history-tab.active {
      background: rgba(99, 102, 241, 0.2);
      color: #a5b4fc;
    }
  </style>
</head>
<body>
  <div id="root"></div>
  <script type="text/babel">
const { useState, useCallback, useEffect, useRef, useMemo } = React;

// ============================================
// CONFIGURATION
// ============================================

const AIRTABLE_BASE_ID = 'app1tsUyKa7F3sy0D';
const CLIENT_INFO_TABLE = 'Client Info';

// Password hashes for authentication
const ALL_CLIENTS_HASH = '66a0dda85ec791a862a57ac9d0ffca6a3aa3310cbe367ff2cd73e29dde2b0abd';
const BAHR_ONLY_HASH = '472e01695e25f97cfc5d3418bd69628c485e539247712436973c2802f7c409bd';

// Match tier definitions
const MATCH_TIERS = {
  TIER1: { tier: 1, name: 'Definitive', color: '#10b981', minConfidence: 100 },
  TIER2: { tier: 2, name: 'Strong', color: '#6366f1', minConfidence: 85 },
  TIER3: { tier: 3, name: 'Possible', color: '#f59e0b', minConfidence: 70 },
  TIER4: { tier: 4, name: 'Investigate', color: '#ef4444', minConfidence: 0 },
};

// Fields to exclude from merging
const EXCLUDE_FROM_MERGE = ['Box_Folder_ID', 'box_shared_link', 'Box Legacy ID'];

// Nickname mappings for name matching
const NICKNAMES = {
  'robert': ['bob', 'bobby', 'rob'], 'bob': ['robert'],
  'william': ['bill', 'billy', 'will', 'liam'], 'bill': ['william'],
  'richard': ['rick', 'ricky', 'dick'], 'rick': ['richard'],
  'james': ['jim', 'jimmy', 'jamie'], 'jim': ['james'],
  'michael': ['mike', 'mikey'], 'mike': ['michael'],
  'elizabeth': ['liz', 'beth', 'betty', 'lisa'], 'liz': ['elizabeth'],
  'jennifer': ['jen', 'jenny'], 'jen': ['jennifer'],
  'joseph': ['joe', 'joey'], 'joe': ['joseph'],
  'daniel': ['dan', 'danny'], 'dan': ['daniel'],
  'jose': ['pepe', 'joe'], 'francisco': ['paco', 'frank'],
  'guadalupe': ['lupe', 'lupita'], 'miguel': ['mike'],
  'guillermo': ['memo', 'william'], 'roberto': ['robert', 'beto'],
  'eduardo': ['eddie', 'lalo'], 'alejandro': ['alex'],
};

// ============================================
// UTILITY FUNCTIONS
// ============================================

const hashPassword = async (password) => {
  const encoder = new TextEncoder();
  const data = encoder.encode(password);
  const hashBuffer = await crypto.subtle.digest('SHA-256', data);
  return Array.from(new Uint8Array(hashBuffer)).map(b => b.toString(16).padStart(2, '0')).join('');
};

const removeAccents = (str) => str ? str.normalize('NFD').replace(/[\u0300-\u036f]/g, '') : '';

const normalizeName = (name) => {
  if (!name) return '';
  return removeAccents(name).toLowerCase().trim()
    .replace(/\s*,\s*/g, ' ')
    .replace(/[.,\-'"()]/g, '')
    .replace(/\s+/g, ' ')
    .replace(/\b(jr|sr|ii|iii|iv|dr|mr|mrs|ms)\b\.?/gi, '')
    .trim();
};

const normalizePhone = (phone) => phone ? phone.replace(/\D/g, '').slice(-10) : '';

const levenshteinDistance = (a, b) => {
  if (!a || !b) return Math.max((a||'').length, (b||'').length);
  const matrix = Array(b.length + 1).fill(null).map(() => Array(a.length + 1).fill(null));
  for (let i = 0; i <= a.length; i++) matrix[0][i] = i;
  for (let j = 0; j <= b.length; j++) matrix[j][0] = j;
  for (let j = 1; j <= b.length; j++) {
    for (let i = 1; i <= a.length; i++) {
      const cost = a[i-1] === b[j-1] ? 0 : 1;
      matrix[j][i] = Math.min(matrix[j][i-1] + 1, matrix[j-1][i] + 1, matrix[j-1][i-1] + cost);
    }
  }
  return matrix[b.length][a.length];
};

const stringSimilarity = (a, b) => {
  if (!a && !b) return 100;
  if (!a || !b) return 0;
  const dist = levenshteinDistance(a.toLowerCase(), b.toLowerCase());
  return Math.round((1 - dist / Math.max(a.length, b.length)) * 100);
};

const areNamesRelated = (name1, name2) => {
  const n1 = normalizeName(name1);
  const n2 = normalizeName(name2);
  if (n1 === n2) return { match: true, score: 100, reason: 'exact' };

  const parts1 = n1.split(' ').filter(Boolean);
  const parts2 = n2.split(' ').filter(Boolean);

  // Check nickname matches
  for (const p1 of parts1) {
    for (const p2 of parts2) {
      if (p1 === p2) continue;
      const nicks1 = NICKNAMES[p1] || [];
      const nicks2 = NICKNAMES[p2] || [];
      if (nicks1.includes(p2) || nicks2.includes(p1)) {
        return { match: true, score: 95, reason: 'nickname' };
      }
    }
  }

  // Fuzzy match
  const sim = stringSimilarity(n1, n2);
  if (sim >= 85) return { match: true, score: sim, reason: 'fuzzy' };

  // Shared parts
  const shared = parts1.filter(p => parts2.includes(p));
  if (shared.length >= 2) return { match: true, score: 80, reason: 'shared_parts' };

  return { match: false, score: sim, reason: 'no_match' };
};

const generateMergeId = () => 'mrg_' + Math.random().toString(36).substr(2, 9);

// ============================================
// AIRTABLE CLIENT
// ============================================

class AirtableClient {
  constructor(apiKey, baseId) {
    this.apiKey = apiKey;
    this.baseId = baseId;
    this.baseUrl = `https://api.airtable.com/v0/${baseId}`;
    this.metaUrl = `https://api.airtable.com/v0/meta/bases/${baseId}/tables`;
  }

  async request(url, options = {}) {
    const response = await fetch(url, {
      ...options,
      headers: { 'Authorization': `Bearer ${this.apiKey}`, 'Content-Type': 'application/json', ...options.headers },
    });
    if (!response.ok) {
      const error = await response.json().catch(() => ({}));
      throw new Error(error.error?.message || `API error: ${response.status}`);
    }
    return response.json();
  }

  async getTableSchema(tableName) {
    const result = await this.request(this.metaUrl);
    const table = result.tables.find(t => t.name === tableName);
    if (!table) throw new Error(`Table "${tableName}" not found`);

    const computedTypes = ['formula', 'rollup', 'count', 'lookup', 'multipleLookupValues', 'autoNumber', 'createdTime', 'lastModifiedTime', 'createdBy', 'lastModifiedBy', 'button'];
    const schema = { writableFields: [], computedFields: [], linkFields: [], textFields: [] };

    table.fields.forEach(field => {
      const isComputed = computedTypes.includes(field.type) || field.name.includes('(from');
      if (isComputed) {
        schema.computedFields.push(field.name);
      } else {
        schema.writableFields.push(field.name);
        if (field.type === 'multipleRecordLinks') schema.linkFields.push(field.name);
        else schema.textFields.push(field.name);
      }
    });
    return schema;
  }

  async getAllRecords(tableName, fields = [], filterFormula = '', onProgress = null) {
    const allRecords = [];
    let offset = null, page = 0;
    do {
      const params = new URLSearchParams();
      fields.forEach(f => params.append('fields[]', f));
      if (filterFormula) params.append('filterByFormula', filterFormula);
      if (offset) params.append('offset', offset);
      params.append('pageSize', '100');

      const result = await this.request(`${this.baseUrl}/${encodeURIComponent(tableName)}?${params}`);
      allRecords.push(...result.records);
      offset = result.offset;
      page++;
      if (onProgress) onProgress({ page, total: allRecords.length, hasMore: !!offset });
      if (offset) await new Promise(r => setTimeout(r, 200));
    } while (offset);
    return allRecords;
  }

  async updateRecord(tableName, recordId, fields) {
    return this.request(`${this.baseUrl}/${encodeURIComponent(tableName)}/${recordId}`, {
      method: 'PATCH', body: JSON.stringify({ fields }),
    });
  }

  async createRecord(tableName, fields) {
    return this.request(`${this.baseUrl}/${encodeURIComponent(tableName)}`, {
      method: 'POST', body: JSON.stringify({ fields }),
    });
  }

  async deleteRecord(tableName, recordId) {
    return this.request(`${this.baseUrl}/${encodeURIComponent(tableName)}/${recordId}`, { method: 'DELETE' });
  }
}

// ============================================
// MATCHING ENGINE
// ============================================

const scoreRecordQuality = (record) => {
  const f = record.fields || {};
  let score = 0;
  if (f['A#']?.trim()) score += 50;
  if (f['DOB']) score += 30;
  if (f['clio_contact_id']) score += 25;
  if (f['PPID']) score += 20;
  if (f['Box_Folder_ID']) score += 40;
  if (f['Phone Number']?.trim()) score += 15;
  if (f['Client Email']?.trim() && !f['Client Email'].includes('null@blank')) score += 15;
  if (f['Address Line 1'] || f['Address']) score += 10;
  score += (f['Case Master View'] || []).length * 100;
  score += (f['Events'] || []).length * 50;
  score += (f['Relationships'] || []).length * 30;
  score += (f['Matters'] || []).length * 80;
  score += (f['Client Notes'] || []).length * 20;
  if (f['First Name']) score += 5;
  if (f['Family Name']) score += 5;
  return score;
};

const getDisplayName = (record) => {
  const f = record.fields || {};
  return f['Full_Name_Normal_Pretty'] || f['Client Name'] ||
    [f['First Name'], f['Middle Name'], f['Family Name']].filter(Boolean).join(' ') || record.id;
};

const scoreMatch = (recordA, recordB) => {
  const fa = recordA.fields || {}, fb = recordB.fields || {};
  const reasons = [], conflicts = [];
  let confidence = 0;
  let hasIdMatch = false;

  // Check for ID conflicts first
  const idFields = ['PPID', 'clio_contact_id', 'A#'];
  for (const field of idFields) {
    if (fa[field] && fb[field]) {
      if (fa[field] === fb[field]) {
        reasons.push(`${field} exact`);
        hasIdMatch = true;
      } else {
        conflicts.push(`${field}: "${fa[field]}" vs "${fb[field]}"`);
      }
    }
  }

  if (conflicts.length > 0) {
    return { tier: MATCH_TIERS.TIER4, confidence: 50, reasons, conflicts, isConflict: true };
  }

  // TIER 1: Full name exact match (100%)
  const nameA = [fa['First Name'], fa['Family Name']].filter(Boolean).join(' ') || fa['Client Name'];
  const nameB = [fb['First Name'], fb['Family Name']].filter(Boolean).join(' ') || fb['Client Name'];
  if (nameA && nameB) {
    const nameMatch = areNamesRelated(nameA, nameB);
    if (nameMatch.match) {
      reasons.push(`Name ${nameMatch.score}% (${nameMatch.reason})`);
      confidence = nameMatch.score;

      // Exact full name match is Tier 1 (Definitive)
      if (nameMatch.score === 100 && nameMatch.reason === 'exact') {
        return { tier: MATCH_TIERS.TIER1, confidence: 100, reasons, conflicts, isConflict: false };
      }
    }
  }

  // TIER 2: PPID/ID exact match OR name match with corroboration
  if (hasIdMatch) {
    confidence = Math.max(confidence, 90);
    // ID match alone is strong but not definitive
  }

  // Corroborating fields boost confidence
  let corroboration = 0;
  const phoneA = normalizePhone(fa['Phone Number']), phoneB = normalizePhone(fb['Phone Number']);
  if (phoneA && phoneB && phoneA.length >= 10 && phoneA === phoneB) {
    reasons.push('Phone exact');
    corroboration++;
    confidence = Math.min(100, confidence + 10);
  }

  if (fa['DOB'] && fb['DOB'] && fa['DOB'] === fb['DOB']) {
    reasons.push('DOB exact');
    corroboration++;
    confidence = Math.min(100, confidence + 15);
  }

  const emailA = (fa['Client Email'] || '').toLowerCase(), emailB = (fb['Client Email'] || '').toLowerCase();
  if (emailA && emailB && !emailA.includes('null@blank') && emailA === emailB) {
    reasons.push('Email exact');
    corroboration++;
    confidence = Math.min(100, confidence + 10);
  }

  // Determine tier (PPID/ID matches are Tier 2, not Tier 1)
  let tier;
  if (hasIdMatch || confidence >= 85 || (confidence >= 75 && corroboration >= 1)) {
    tier = MATCH_TIERS.TIER2;
  } else if (confidence >= 70) {
    tier = MATCH_TIERS.TIER3;
  } else {
    tier = MATCH_TIERS.TIER3;
  }

  return { tier, confidence: Math.round(Math.max(confidence, 70)), reasons, conflicts, isConflict: false };
};

const findDuplicateCandidates = (records, onProgress) => {
  const candidates = [];
  const processed = new Set();

  // Group by normalized name for efficiency
  const groups = new Map();
  records.forEach((record, idx) => {
    const f = record.fields || {};
    const key = normalizeName([f['First Name'], f['Family Name']].filter(Boolean).join(' ') || f['Client Name'] || '');
    if (!key) return;
    if (!groups.has(key)) groups.set(key, []);
    groups.get(key).push({ record, idx });
  });

  let groupNum = 0;
  groups.forEach((group, key) => {
    groupNum++;
    if (group.length < 2) return;

    for (let i = 0; i < group.length; i++) {
      for (let j = i + 1; j < group.length; j++) {
        const pairKey = [group[i].record.id, group[j].record.id].sort().join('|');
        if (processed.has(pairKey)) continue;
        processed.add(pairKey);

        const match = scoreMatch(group[i].record, group[j].record);
        if (match.confidence >= 70 || match.isConflict) {
          const scoreA = scoreRecordQuality(group[i].record);
          const scoreB = scoreRecordQuality(group[j].record);
          const [survivor, merged] = scoreA >= scoreB ? [group[i], group[j]] : [group[j], group[i]];

          candidates.push({
            id: `match_${candidates.length}`,
            ...match,
            survivor: { record: survivor.record, score: Math.max(scoreA, scoreB), name: getDisplayName(survivor.record) },
            merged: { record: merged.record, score: Math.min(scoreA, scoreB), name: getDisplayName(merged.record) },
          });
        }
      }
    }
    if (onProgress && groupNum % 50 === 0) onProgress({ phase: 'matching', current: groupNum, total: groups.size });
  });

  candidates.sort((a, b) => a.tier.tier - b.tier.tier || b.confidence - a.confidence);
  return candidates;
};

// ============================================
// HISTORY FUNCTIONS
// ============================================

const parseDedupeHistory = (historyField) => {
  if (!historyField) return [];
  try {
    const parsed = JSON.parse(historyField);
    if (Array.isArray(parsed)) return parsed;
    return [];
  } catch { return []; }
};

const buildMergeHistoryEntry = (survivor, merged, fieldDecisions, matchInfo, notes = '') => ({
  merge_id: generateMergeId(),
  timestamp: new Date().toISOString(),
  action: 'merge',
  confidence: matchInfo.confidence,
  match_reasons: matchInfo.reasons,
  survivor_record_id: survivor.record.id,
  merged_records: [{
    original_record_id: merged.record.id,
    field_snapshot: { ...merged.record.fields },
  }],
  field_decisions: fieldDecisions,
  performed_by: 'user',
  notes,
});

// ============================================
// LOGIN COMPONENT
// ============================================

function LoginScreen({ onLogin }) {
  const [password, setPassword] = useState('');
  const [error, setError] = useState('');
  const [loading, setLoading] = useState(false);

  const handleSubmit = async (e) => {
    e.preventDefault();
    setLoading(true);
    try {
      const hash = await hashPassword(password);
      if (hash === ALL_CLIENTS_HASH) onLogin('all');
      else if (hash === BAHR_ONLY_HASH) onLogin('bahr');
      else setError('Invalid password');
    } catch { setError('Authentication error'); }
    finally { setLoading(false); }
  };

  return (
    <div className="container" style={{ display: 'flex', alignItems: 'center', justifyContent: 'center', minHeight: '100vh' }}>
      <div className="card" style={{ maxWidth: '400px', width: '100%' }}>
        <h1 style={{ textAlign: 'center' }}>Airtable Dedupe</h1>
        <p className="subtitle" style={{ textAlign: 'center' }}>Client Deduplication Tool</p>
        <form onSubmit={handleSubmit}>
          <div className="input-group">
            <label>Password</label>
            <input type="password" value={password} onChange={e => setPassword(e.target.value)} placeholder="Enter access password" autoFocus />
          </div>
          {error && <div style={{ color: '#ef4444', marginBottom: '15px', textAlign: 'center' }}>{error}</div>}
          <button type="submit" className="primary" disabled={loading || !password} style={{ width: '100%' }}>
            {loading ? 'Verifying...' : 'Login'}
          </button>
        </form>
      </div>
    </div>
  );
}

// ============================================
// MERGE REVIEW MODAL
// ============================================

function MergeReviewModal({ candidate, schema, credentials, onComplete, onSkip, onClose, addLog }) {
  const [fieldDecisions, setFieldDecisions] = useState({});
  const [notes, setNotes] = useState('');
  const [merging, setMerging] = useState(false);

  const survivorFields = candidate.survivor.record.fields || {};
  const mergedFields = candidate.merged.record.fields || {};

  // Get all unique field names
  const allFieldNames = useMemo(() => {
    const names = new Set([...Object.keys(survivorFields), ...Object.keys(mergedFields)]);
    return Array.from(names).sort();
  }, [survivorFields, mergedFields]);

  // Initialize decisions
  useEffect(() => {
    const decisions = {};
    allFieldNames.forEach(fieldName => {
      const isComputed = schema.computedFields.includes(fieldName);
      const isExcluded = EXCLUDE_FROM_MERGE.includes(fieldName);
      const valA = survivorFields[fieldName];
      const valB = mergedFields[fieldName];
      const isEmpty = (v) => v === null || v === undefined || (typeof v === 'string' && !v.trim()) || (Array.isArray(v) && v.length === 0);

      if (isComputed || isExcluded) {
        decisions[fieldName] = { strategy: 'skip', value: null, include: false };
      } else if (JSON.stringify(valA) === JSON.stringify(valB)) {
        decisions[fieldName] = { strategy: 'auto', value: valA, include: !isEmpty(valA) };
      } else if (isEmpty(valA) && !isEmpty(valB)) {
        decisions[fieldName] = { strategy: 'keep_b', value: valB, include: true };
      } else if (!isEmpty(valA) && isEmpty(valB)) {
        decisions[fieldName] = { strategy: 'keep_a', value: valA, include: true };
      } else if (schema.linkFields.includes(fieldName)) {
        // Merge link fields
        const merged = [...new Set([...(valA || []), ...(valB || [])])];
        decisions[fieldName] = { strategy: 'merge', value: merged, include: merged.length > 0 };
      } else {
        // Need manual decision
        decisions[fieldName] = { strategy: 'pending', value: null, include: true, needsDecision: true };
      }
    });
    setFieldDecisions(decisions);
  }, [candidate, schema]);

  const pendingDecisions = Object.entries(fieldDecisions).filter(([_, d]) => d.needsDecision);

  const handlePick = (fieldName, pick) => {
    const valA = survivorFields[fieldName];
    const valB = mergedFields[fieldName];
    setFieldDecisions(prev => ({
      ...prev,
      [fieldName]: { strategy: pick, value: pick === 'keep_a' ? valA : valB, include: true, needsDecision: false }
    }));
  };

  const handleMerge = async () => {
    if (pendingDecisions.length > 0) {
      addLog(`Please resolve ${pendingDecisions.length} field conflict(s) first`, 'error');
      return;
    }

    setMerging(true);
    try {
      const client = new AirtableClient(credentials.apiKey, credentials.baseId);

      // Build update payload
      const updateFields = {};
      Object.entries(fieldDecisions).forEach(([fieldName, decision]) => {
        if (decision.include && !schema.computedFields.includes(fieldName) && !EXCLUDE_FROM_MERGE.includes(fieldName)) {
          updateFields[fieldName] = decision.value;
        }
      });

      // Build history entry
      const historyEntry = buildMergeHistoryEntry(candidate.survivor, candidate.merged, fieldDecisions, candidate, notes);
      const existingHistory = parseDedupeHistory(survivorFields['dedupe_history']);
      existingHistory.push(historyEntry);
      updateFields['dedupe_history'] = JSON.stringify(existingHistory, null, 2);

      addLog(`Merging ${candidate.merged.name} into ${candidate.survivor.name}...`, 'info');
      await client.updateRecord(credentials.tableName, candidate.survivor.record.id, updateFields);
      addLog('Survivor record updated', 'success');

      addLog(`Deleting merged record ${candidate.merged.record.id}...`, 'info');
      await client.deleteRecord(credentials.tableName, candidate.merged.record.id);
      addLog('Merged record deleted', 'success');

      onComplete(historyEntry);
    } catch (err) {
      addLog(`Merge failed: ${err.message}`, 'error');
    } finally {
      setMerging(false);
    }
  };

  const formatValue = (val) => {
    if (val === null || val === undefined) return null;
    if (Array.isArray(val)) return val.length === 0 ? null : `[${val.length} items]`;
    if (typeof val === 'boolean') return val ? 'Yes' : 'No';
    const str = String(val);
    return str.length > 50 ? str.slice(0, 50) + '...' : str;
  };

  return (
    <div className="modal-overlay" onClick={onClose}>
      <div className="modal" onClick={e => e.stopPropagation()}>
        <div className="modal-header">
          <div>
            <h2>Review Merge</h2>
            <div style={{ display: 'flex', alignItems: 'center', gap: '10px', marginTop: '5px' }}>
              <span className={`badge tier${candidate.tier.tier}`}>{candidate.confidence}%</span>
              <span style={{ color: '#94a3b8' }}>{candidate.tier.name} Match</span>
              <div style={{ display: 'flex', gap: '5px', marginLeft: '10px' }}>
                {candidate.reasons.map((r, i) => <span key={i} className="reason-tag">{r}</span>)}
              </div>
            </div>
          </div>
          <button className="modal-close" onClick={onClose}>&times;</button>
        </div>

        <div className="modal-body">
          {candidate.conflicts && candidate.conflicts.length > 0 && (
            <div style={{ background: 'rgba(239, 68, 68, 0.1)', border: '1px solid #ef4444', borderRadius: '8px', padding: '15px', marginBottom: '15px' }}>
              <strong style={{ color: '#ef4444' }}>‚ö†Ô∏è Data Conflicts:</strong>
              <ul style={{ margin: '10px 0 0 20px', color: '#ef4444' }}>
                {candidate.conflicts.map((c, i) => <li key={i}>{c}</li>)}
              </ul>
            </div>
          )}

          <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '15px', marginBottom: '15px' }}>
            <div style={{ background: 'rgba(16, 185, 129, 0.1)', border: '1px solid #10b981', borderRadius: '8px', padding: '15px' }}>
              <div style={{ display: 'flex', alignItems: 'center', gap: '10px', marginBottom: '5px' }}>
                <span className="badge keep">KEEP</span>
                <strong>{candidate.survivor.name}</strong>
              </div>
              <div style={{ fontSize: '0.85em', color: '#94a3b8' }}>Score: {candidate.survivor.score} | ID: {candidate.survivor.record.id}</div>
            </div>
            <div style={{ background: 'rgba(245, 158, 11, 0.1)', border: '1px solid #f59e0b', borderRadius: '8px', padding: '15px' }}>
              <div style={{ display: 'flex', alignItems: 'center', gap: '10px', marginBottom: '5px' }}>
                <span className="badge merge">MERGE</span>
                <strong>{candidate.merged.name}</strong>
              </div>
              <div style={{ fontSize: '0.85em', color: '#94a3b8' }}>Score: {candidate.merged.score} | ID: {candidate.merged.record.id}</div>
            </div>
          </div>

          <div className="diff-container">
            <div className="diff-header">Field</div>
            <div className="diff-header">Record A (Keep)</div>
            <div className="diff-header">Record B (Merge)</div>
            <div className="diff-header">Resolution</div>

            {allFieldNames.map(fieldName => {
              const decision = fieldDecisions[fieldName] || {};
              const valA = survivorFields[fieldName];
              const valB = mergedFields[fieldName];
              const isComputed = schema.computedFields.includes(fieldName);
              const isExcluded = EXCLUDE_FROM_MERGE.includes(fieldName);
              const isSame = JSON.stringify(valA) === JSON.stringify(valB);
              const dispA = formatValue(valA);
              const dispB = formatValue(valB);

              return (
                <div key={fieldName} className="diff-row">
                  <div className={`diff-cell field-name ${isComputed ? 'computed' : ''}`}>
                    {fieldName}
                    {isComputed && <span style={{ fontSize: '0.7em', marginLeft: '5px' }}>(computed)</span>}
                    {isExcluded && <span style={{ fontSize: '0.7em', marginLeft: '5px', color: '#f59e0b' }}>(excluded)</span>}
                  </div>
                  <div
                    className={`diff-cell ${isSame ? 'same' : 'different'} ${decision.strategy === 'keep_a' ? 'selected' : ''} ${!isSame && !isComputed && !isExcluded ? 'clickable' : ''}`}
                    onClick={() => !isSame && !isComputed && !isExcluded && handlePick(fieldName, 'keep_a')}
                  >
                    {dispA || <span className="empty-value">(empty)</span>}
                  </div>
                  <div
                    className={`diff-cell ${isSame ? 'same' : 'different'} ${decision.strategy === 'keep_b' ? 'selected' : ''} ${!isSame && !isComputed && !isExcluded ? 'clickable' : ''}`}
                    onClick={() => !isSame && !isComputed && !isExcluded && handlePick(fieldName, 'keep_b')}
                  >
                    {dispB || <span className="empty-value">(empty)</span>}
                  </div>
                  <div className="diff-cell">
                    {isComputed || isExcluded ? (
                      <span style={{ color: '#64748b', fontSize: '0.8em' }}>Skip</span>
                    ) : isSame ? (
                      <span className="pick-btn auto">Auto</span>
                    ) : decision.strategy === 'merge' ? (
                      <span className="pick-btn auto">Merged</span>
                    ) : (
                      <div className="pick-buttons">
                        <button className={`pick-btn ${decision.strategy === 'keep_a' ? 'active' : ''}`} onClick={() => handlePick(fieldName, 'keep_a')}>A</button>
                        <button className={`pick-btn ${decision.strategy === 'keep_b' ? 'active' : ''}`} onClick={() => handlePick(fieldName, 'keep_b')}>B</button>
                      </div>
                    )}
                  </div>
                </div>
              );
            })}
          </div>

          <div className="input-group" style={{ marginTop: '15px' }}>
            <label>Notes (optional)</label>
            <textarea value={notes} onChange={e => setNotes(e.target.value)} placeholder="Add any notes about this merge..." rows={2} />
          </div>

          {pendingDecisions.length > 0 && (
            <div style={{ color: '#f59e0b', textAlign: 'center', marginTop: '10px' }}>
              Please resolve {pendingDecisions.length} field conflict(s): {pendingDecisions.map(([n]) => n).join(', ')}
            </div>
          )}
        </div>

        <div className="modal-footer">
          <button className="secondary" onClick={onSkip} disabled={merging}>Skip</button>
          <button className="warning" onClick={onClose} disabled={merging}>Not a Duplicate</button>
          <button className="success" onClick={handleMerge} disabled={merging || pendingDecisions.length > 0}>
            {merging ? 'Merging...' : 'Merge Records'}
          </button>
        </div>
      </div>
    </div>
  );
}

// ============================================
// HISTORY VIEWER
// ============================================

// Helper to format a field value for display
const formatFieldValue = (value) => {
  if (value === null || value === undefined) return '(empty)';
  if (Array.isArray(value)) {
    if (value.length === 0) return '(empty)';
    return value.length <= 3 ? value.join(', ') : `${value.slice(0, 3).join(', ')} (+${value.length - 3} more)`;
  }
  if (typeof value === 'boolean') return value ? 'Yes' : 'No';
  if (typeof value === 'object') return JSON.stringify(value);
  const str = String(value);
  return str.length > 60 ? str.slice(0, 60) + '...' : str;
};

// Helper to get a human-readable name from a merged record
const getMergedRecordName = (mergedRecord) => {
  const fields = mergedRecord.field_snapshot || {};
  const firstName = fields['First Name'] || '';
  const lastName = fields['Family Name'] || '';
  if (firstName || lastName) return `${firstName} ${lastName}`.trim();
  return fields['Client Name'] || mergedRecord.original_record_id || 'Unknown';
};

// Component to display a single merged record's details
function MergedRecordDetails({ mergedRecord, eventIdx, recordIdx, onUnmerge, isUnmerged, unmergeInfo, unmerging, confirmUnmerge, setConfirmUnmerge }) {
  const fields = mergedRecord.field_snapshot || {};
  const importantFields = ['First Name', 'Family Name', 'Client Name', 'DOB', 'PPID', 'A#', 'Phone Number', 'Client Email', 'Country', 'Address Line 1'];
  const displayFields = importantFields.filter(f => fields[f]);
  const isConfirming = confirmUnmerge?.eventIdx === eventIdx && confirmUnmerge?.mergedRecordIdx === recordIdx;

  return (
    <div className="merged-record-card" style={isUnmerged ? { opacity: 0.6, borderColor: 'rgba(16, 185, 129, 0.3)', background: 'rgba(16, 185, 129, 0.05)' } : {}}>
      <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'flex-start', marginBottom: '10px' }}>
        <div>
          <h4 style={{ margin: 0 }}>
            <span style={{ fontSize: '1.1em' }}>{isUnmerged ? '‚úÖ' : 'üìã'}</span>
            {' '}{isUnmerged ? 'Restored:' : 'Merged record:'} {getMergedRecordName(mergedRecord)}
          </h4>
          <div style={{ fontSize: '0.8em', color: '#94a3b8', marginTop: '5px' }}>
            Original ID: <code style={{ background: '#0f172a', padding: '2px 6px', borderRadius: '4px' }}>{mergedRecord.original_record_id}</code>
          </div>
        </div>
        <div>
          {isUnmerged ? (
            <div style={{
              background: 'rgba(16, 185, 129, 0.2)',
              color: '#10b981',
              padding: '6px 12px',
              borderRadius: '6px',
              fontSize: '0.8em',
              fontWeight: '500'
            }}>
              Restored as {unmergeInfo?.restored_record_id}
              <div style={{ fontSize: '0.75em', opacity: 0.8, marginTop: '2px' }}>
                {new Date(unmergeInfo?.unmerged_at).toLocaleDateString()}
              </div>
            </div>
          ) : isConfirming ? (
            <div style={{ display: 'flex', gap: '8px', alignItems: 'center' }}>
              <span style={{ fontSize: '0.8em', color: '#f59e0b' }}>Restore this record?</span>
              <button
                className="success small"
                onClick={() => onUnmerge(eventIdx, recordIdx)}
                disabled={unmerging}
              >
                {unmerging ? 'Restoring...' : 'Yes, Restore'}
              </button>
              <button
                className="secondary small"
                onClick={() => setConfirmUnmerge(null)}
                disabled={unmerging}
              >
                Cancel
              </button>
            </div>
          ) : (
            <button
              className="warning small"
              onClick={() => setConfirmUnmerge({ eventIdx, mergedRecordIdx: recordIdx })}
              title="Restore this record as a separate entry"
            >
              Undo Merge
            </button>
          )}
        </div>
      </div>
      {displayFields.length > 0 && (
        <table className="field-changes-table">
          <thead>
            <tr>
              <th style={{ width: '40%' }}>Field</th>
              <th>Value {isUnmerged ? 'that was restored' : 'at time of merge'}</th>
            </tr>
          </thead>
          <tbody>
            {displayFields.map(fieldName => (
              <tr key={fieldName}>
                <td style={{ color: '#94a3b8' }}>{fieldName}</td>
                <td>{formatFieldValue(fields[fieldName])}</td>
              </tr>
            ))}
          </tbody>
        </table>
      )}
    </div>
  );
}

function HistoryViewer({ credentials, addLog }) {
  const [searchQuery, setSearchQuery] = useState('');
  const [searchResults, setSearchResults] = useState([]);
  const [selectedRecord, setSelectedRecord] = useState(null);
  const [history, setHistory] = useState([]);
  const [expandedEvents, setExpandedEvents] = useState(new Set());
  const [searching, setSearching] = useState(false);
  const [detailTab, setDetailTab] = useState('summary'); // 'summary', 'fields', 'raw'
  const [unmerging, setUnmerging] = useState(false);
  const [confirmUnmerge, setConfirmUnmerge] = useState(null); // { eventIdx, mergedRecordIdx }

  const handleSearch = async () => {
    if (!searchQuery.trim()) return;
    setSearching(true);
    try {
      const client = new AirtableClient(credentials.apiKey, credentials.baseId);
      const filter = `OR(FIND(LOWER("${searchQuery.toLowerCase()}"), LOWER({Client Name})), FIND("${searchQuery}", {PPID}), RECORD_ID() = "${searchQuery}")`;
      const results = await client.getAllRecords(credentials.tableName, ['Client Name', 'PPID', 'dedupe_history', 'First Name', 'Family Name'], filter);
      setSearchResults(results);
      if (results.length === 0) addLog('No records found', 'warning');
      else addLog(`Found ${results.length} records`, 'success');
    } catch (err) {
      addLog(`Search failed: ${err.message}`, 'error');
    } finally {
      setSearching(false);
    }
  };

  const selectRecord = (record) => {
    setSelectedRecord(record);
    const hist = parseDedupeHistory(record.fields.dedupe_history);
    setHistory(hist);
    // Auto-expand first event if there's history
    if (hist.length > 0) {
      setExpandedEvents(new Set([hist[0].merge_id || 0]));
    }
  };

  const toggleEvent = (id) => {
    setExpandedEvents(prev => {
      const next = new Set(prev);
      if (next.has(id)) next.delete(id);
      else next.add(id);
      return next;
    });
  };

  const formatDate = (timestamp) => {
    const date = new Date(timestamp);
    return date.toLocaleDateString('en-US', {
      month: 'short',
      day: 'numeric',
      year: 'numeric',
      hour: 'numeric',
      minute: '2-digit'
    });
  };

  const getActionDescription = (event) => {
    if (event.action === 'merge') {
      const count = event.merged_records?.length || 0;
      const names = event.merged_records?.map(r => getMergedRecordName(r)).join(', ') || 'unknown record';
      return count === 1
        ? `Merged "${names}" into this record`
        : `Merged ${count} records into this record`;
    }
    return 'Record was unmerged';
  };

  const handleUnmerge = async (eventIdx, mergedRecordIdx) => {
    if (!selectedRecord || !credentials.apiKey) return;

    setUnmerging(true);
    try {
      const client = new AirtableClient(credentials.apiKey, credentials.baseId);
      const event = history[eventIdx];
      const mergedRecord = event.merged_records[mergedRecordIdx];

      if (!mergedRecord?.field_snapshot) {
        addLog('Cannot unmerge: no field snapshot available', 'error');
        return;
      }

      addLog(`Restoring record: ${getMergedRecordName(mergedRecord)}...`, 'info');

      // Filter out computed fields and prepare writable fields
      const fieldsToRestore = { ...mergedRecord.field_snapshot };
      // Remove fields that shouldn't be restored
      delete fieldsToRestore.dedupe_history;

      // Create the restored record
      const restored = await client.createRecord(credentials.tableName, fieldsToRestore);
      addLog(`Record restored with new ID: ${restored.id}`, 'success');

      // Update history to mark this as unmerged
      const updatedHistory = [...history];
      if (!updatedHistory[eventIdx].unmerged_records) {
        updatedHistory[eventIdx].unmerged_records = [];
      }
      updatedHistory[eventIdx].unmerged_records.push({
        original_record_id: mergedRecord.original_record_id,
        restored_record_id: restored.id,
        unmerged_at: new Date().toISOString(),
        unmerged_by: 'user'
      });

      // Update the survivor record's history
      await client.updateRecord(credentials.tableName, selectedRecord.id, {
        dedupe_history: JSON.stringify(updatedHistory, null, 2)
      });

      setHistory(updatedHistory);
      addLog('Unmerge completed successfully!', 'success');
      setConfirmUnmerge(null);

    } catch (err) {
      addLog(`Unmerge failed: ${err.message}`, 'error');
    } finally {
      setUnmerging(false);
    }
  };

  const isRecordUnmerged = (event, mergedRecordIdx) => {
    if (!event.unmerged_records) return false;
    const mergedRecord = event.merged_records[mergedRecordIdx];
    return event.unmerged_records.some(
      u => u.original_record_id === mergedRecord.original_record_id
    );
  };

  const getUnmergeInfo = (event, mergedRecordIdx) => {
    if (!event.unmerged_records) return null;
    const mergedRecord = event.merged_records[mergedRecordIdx];
    return event.unmerged_records.find(
      u => u.original_record_id === mergedRecord.original_record_id
    );
  };

  return (
    <div className="card">
      <h2>Merge History</h2>
      <p className="subtitle">Search for a client to see their complete merge history</p>

      <div style={{ display: 'flex', gap: '10px', marginBottom: '20px' }}>
        <input type="text" value={searchQuery} onChange={e => setSearchQuery(e.target.value)}
          placeholder="Search by name, PPID, or record ID..." style={{ flex: 1 }}
          onKeyDown={e => e.key === 'Enter' && handleSearch()} />
        <button className="primary" onClick={handleSearch} disabled={searching}>
          {searching ? 'Searching...' : 'Search'}
        </button>
      </div>

      {searchResults.length > 0 && (
        <div style={{ marginBottom: '20px' }}>
          <h3 style={{ marginBottom: '10px' }}>Search Results ({searchResults.length})</h3>
          <div style={{ maxHeight: '200px', overflowY: 'auto' }}>
            {searchResults.map(record => {
              const historyCount = parseDedupeHistory(record.fields.dedupe_history).length;
              return (
                <div key={record.id} onClick={() => selectRecord(record)}
                  style={{
                    padding: '12px 15px',
                    background: selectedRecord?.id === record.id ? 'rgba(99, 102, 241, 0.2)' : '#1e293b',
                    borderRadius: '8px',
                    marginBottom: '8px',
                    cursor: 'pointer',
                    border: selectedRecord?.id === record.id ? '1px solid rgba(99, 102, 241, 0.5)' : '1px solid transparent',
                    display: 'flex',
                    alignItems: 'center',
                    justifyContent: 'space-between'
                  }}>
                  <div>
                    <div style={{ fontWeight: '500', marginBottom: '4px' }}>{record.fields['Client Name'] || getDisplayName(record)}</div>
                    <div style={{ fontSize: '0.8em', color: '#94a3b8' }}>
                      {record.fields.PPID && <span style={{ marginRight: '10px' }}>PPID: {record.fields.PPID}</span>}
                      <span style={{ opacity: 0.7 }}>ID: {record.id}</span>
                    </div>
                  </div>
                  {historyCount > 0 && (
                    <div style={{
                      background: 'rgba(16, 185, 129, 0.2)',
                      color: '#10b981',
                      padding: '4px 10px',
                      borderRadius: '12px',
                      fontSize: '0.8em',
                      fontWeight: '500'
                    }}>
                      {historyCount} merge{historyCount !== 1 ? 's' : ''}
                    </div>
                  )}
                </div>
              );
            })}
          </div>
        </div>
      )}

      {selectedRecord && (
        <div>
          <div style={{
            background: 'rgba(99, 102, 241, 0.1)',
            border: '1px solid rgba(99, 102, 241, 0.3)',
            borderRadius: '10px',
            padding: '15px 20px',
            marginBottom: '20px'
          }}>
            <h3 style={{ margin: 0, color: '#a5b4fc' }}>
              {selectedRecord.fields['Client Name'] || getDisplayName(selectedRecord)}
            </h3>
            <div style={{ fontSize: '0.85em', color: '#94a3b8', marginTop: '5px' }}>
              {history.length === 0
                ? 'No merge history - this record has not been involved in any merges'
                : `${history.length} merge operation${history.length !== 1 ? 's' : ''} recorded`}
            </div>
          </div>

          {history.length === 0 ? (
            <div style={{
              color: '#94a3b8',
              textAlign: 'center',
              padding: '40px 20px',
              background: '#0f172a',
              borderRadius: '8px'
            }}>
              <div style={{ fontSize: '2em', marginBottom: '10px' }}>üì≠</div>
              <div>No merge history for this record</div>
              <div style={{ fontSize: '0.85em', marginTop: '5px', opacity: 0.7 }}>
                History will appear here after merges are performed
              </div>
            </div>
          ) : (
            <div>
              {history.map((event, idx) => {
                const eventId = event.merge_id || idx;
                const isExpanded = expandedEvents.has(eventId);

                return (
                  <div key={eventId} className={`history-event ${event.action}`}>
                    <div className="history-event-header" onClick={() => toggleEvent(eventId)}>
                      <div className={`history-icon ${event.action === 'merge' ? 'merge-icon' : 'unmerge-icon'}`}>
                        {event.action === 'merge' ? 'üîÄ' : '‚Ü©Ô∏è'}
                      </div>
                      <div style={{ flex: 1 }}>
                        <div style={{ fontWeight: '500', marginBottom: '4px' }}>
                          {getActionDescription(event)}
                        </div>
                        <div style={{ fontSize: '0.85em', color: '#94a3b8', display: 'flex', gap: '15px', flexWrap: 'wrap' }}>
                          <span>üìÖ {formatDate(event.timestamp)}</span>
                          <span style={{
                            background: event.confidence >= 90 ? 'rgba(16, 185, 129, 0.2)' :
                                        event.confidence >= 70 ? 'rgba(99, 102, 241, 0.2)' : 'rgba(245, 158, 11, 0.2)',
                            color: event.confidence >= 90 ? '#10b981' :
                                   event.confidence >= 70 ? '#a5b4fc' : '#f59e0b',
                            padding: '2px 8px',
                            borderRadius: '4px'
                          }}>
                            {event.confidence}% confidence
                          </span>
                        </div>
                      </div>
                      <span style={{
                        color: '#64748b',
                        transition: 'transform 0.2s',
                        transform: isExpanded ? 'rotate(180deg)' : 'rotate(0deg)'
                      }}>‚ñº</span>
                    </div>

                    {isExpanded && (
                      <div className="history-event-body">
                        {/* Tabs for different views */}
                        <div className="history-tabs">
                          <button
                            className={`history-tab ${detailTab === 'summary' ? 'active' : ''}`}
                            onClick={() => setDetailTab('summary')}
                          >
                            Summary
                          </button>
                          <button
                            className={`history-tab ${detailTab === 'fields' ? 'active' : ''}`}
                            onClick={() => setDetailTab('fields')}
                          >
                            Merged Data
                          </button>
                          <button
                            className={`history-tab ${detailTab === 'raw' ? 'active' : ''}`}
                            onClick={() => setDetailTab('raw')}
                          >
                            Raw Data
                          </button>
                        </div>

                        {detailTab === 'summary' && (
                          <div>
                            {/* Summary cards */}
                            <div className="history-summary">
                              <div className="history-summary-item">
                                <div className="label">Why they matched</div>
                                <div className="value">
                                  {event.match_reasons?.map((r, i) => (
                                    <span key={i} className="reason-tag" style={{ marginRight: '5px', marginBottom: '5px' }}>{r}</span>
                                  ))}
                                </div>
                              </div>
                              <div className="history-summary-item">
                                <div className="label">Performed by</div>
                                <div className="value">{event.performed_by || 'User'}</div>
                              </div>
                              <div className="history-summary-item">
                                <div className="label">Records merged</div>
                                <div className="value">{event.merged_records?.length || 0}</div>
                              </div>
                              {event.unmerged_records?.length > 0 && (
                                <div className="history-summary-item" style={{ background: 'rgba(16, 185, 129, 0.1)', borderColor: 'rgba(16, 185, 129, 0.3)' }}>
                                  <div className="label" style={{ color: '#10b981' }}>Records restored</div>
                                  <div className="value" style={{ color: '#10b981' }}>{event.unmerged_records.length}</div>
                                </div>
                              )}
                            </div>

                            {event.notes && (
                              <div style={{
                                background: 'rgba(245, 158, 11, 0.1)',
                                border: '1px solid rgba(245, 158, 11, 0.3)',
                                borderRadius: '8px',
                                padding: '12px 15px',
                                marginBottom: '15px'
                              }}>
                                <div style={{ fontSize: '0.8em', color: '#f59e0b', marginBottom: '5px' }}>Notes</div>
                                <div>{event.notes}</div>
                              </div>
                            )}

                            <div style={{ color: '#94a3b8', fontSize: '0.85em', marginTop: '15px' }}>
                              <strong>Merge ID:</strong> <code style={{ background: '#0f172a', padding: '2px 6px', borderRadius: '4px' }}>{event.merge_id}</code>
                            </div>

                            {/* Quick actions */}
                            {event.merged_records?.some((_, mIdx) => !isRecordUnmerged(event, mIdx)) && (
                              <div style={{
                                marginTop: '20px',
                                paddingTop: '15px',
                                borderTop: '1px solid #334155'
                              }}>
                                <div style={{ fontSize: '0.85em', color: '#94a3b8', marginBottom: '10px' }}>
                                  Quick Actions
                                </div>
                                <button
                                  className="warning"
                                  onClick={() => setDetailTab('fields')}
                                  style={{ display: 'flex', alignItems: 'center', gap: '8px' }}
                                >
                                  <span>‚Ü©Ô∏è</span> View merged records to undo
                                </button>
                              </div>
                            )}
                          </div>
                        )}

                        {detailTab === 'fields' && (
                          <div>
                            {event.merged_records?.map((mergedRecord, mIdx) => (
                              <MergedRecordDetails
                                key={mIdx}
                                mergedRecord={mergedRecord}
                                eventIdx={idx}
                                recordIdx={mIdx}
                                onUnmerge={handleUnmerge}
                                isUnmerged={isRecordUnmerged(event, mIdx)}
                                unmergeInfo={getUnmergeInfo(event, mIdx)}
                                unmerging={unmerging}
                                confirmUnmerge={confirmUnmerge}
                                setConfirmUnmerge={setConfirmUnmerge}
                              />
                            ))}
                          </div>
                        )}

                        {detailTab === 'raw' && (
                          <div>
                            <div style={{ fontSize: '0.85em', color: '#94a3b8', marginBottom: '10px' }}>
                              Complete event data in JSON format:
                            </div>
                            <pre style={{
                              background: '#0f172a',
                              padding: '15px',
                              borderRadius: '8px',
                              overflow: 'auto',
                              maxHeight: '300px',
                              fontSize: '0.8em'
                            }}>{JSON.stringify(event, null, 2)}</pre>
                          </div>
                        )}
                      </div>
                    )}
                  </div>
                );
              })}
            </div>
          )}
        </div>
      )}
    </div>
  );
}

// ============================================
// MAIN APP
// ============================================

function App() {
  const [accessLevel, setAccessLevel] = useState(() => sessionStorage.getItem('access_level') || null);

  const handleLogin = (level) => {
    setAccessLevel(level);
    sessionStorage.setItem('access_level', level);
  };

  if (!accessLevel) return <LoginScreen onLogin={handleLogin} />;
  return <MainApp accessLevel={accessLevel} onLogout={() => { setAccessLevel(null); sessionStorage.removeItem('access_level'); }} />;
}

function MainApp({ accessLevel, onLogout }) {
  const [apiKey, setApiKey] = useState(() => localStorage.getItem('airtable_api_key') || '');
  const [baseId, setBaseId] = useState(AIRTABLE_BASE_ID);
  const [loading, setLoading] = useState(false);
  const [logs, setLogs] = useState([]);
  const [schema, setSchema] = useState(null);
  const [allRecords, setAllRecords] = useState([]);
  const [candidates, setCandidates] = useState([]);
  const [selectedCandidate, setSelectedCandidate] = useState(null);
  const [activeTab, setActiveTab] = useState('scan');
  const [tierFilter, setTierFilter] = useState('all');
  const [searchFilter, setSearchFilter] = useState('');

  const logRef = useRef(null);
  const isBahrOnly = accessLevel === 'bahr';
  const credentials = { apiKey, baseId, tableName: CLIENT_INFO_TABLE };

  useEffect(() => { if (apiKey) localStorage.setItem('airtable_api_key', apiKey); }, [apiKey]);
  useEffect(() => { if (logRef.current) logRef.current.scrollTop = logRef.current.scrollHeight; }, [logs]);

  const addLog = useCallback((message, type = 'info') => {
    setLogs(prev => [...prev, { message, type, timestamp: new Date().toLocaleTimeString() }]);
  }, []);

  const fetchAndScan = async () => {
    if (!apiKey) { addLog('Please enter API key', 'error'); return; }
    setLoading(true);
    setLogs([]);
    try {
      const client = new AirtableClient(apiKey, baseId);

      addLog('Fetching table schema...', 'info');
      const tableSchema = await client.getTableSchema(CLIENT_INFO_TABLE);
      setSchema(tableSchema);
      addLog(`Schema: ${tableSchema.writableFields.length} writable, ${tableSchema.computedFields.length} computed fields`, 'success');

      const filter = isBahrOnly ? '{Bahr Client}' : '';
      addLog(`Fetching ${isBahrOnly ? 'Bahr clients' : 'all clients'}...`, 'info');

      const records = await client.getAllRecords(CLIENT_INFO_TABLE, [...tableSchema.writableFields, 'dedupe_history'], filter,
        (p) => addLog(`Page ${p.page}: ${p.total} records`, 'info'));

      setAllRecords(records);
      addLog(`Fetched ${records.length} records`, 'success');

      addLog('Analyzing for duplicates...', 'info');
      const dupes = findDuplicateCandidates(records, (p) => {
        if (p.current % 100 === 0) addLog(`Matching: ${p.current}/${p.total} groups`, 'info');
      });
      setCandidates(dupes);

      const byTier = { 1: 0, 2: 0, 3: 0, 4: 0 };
      dupes.forEach(c => byTier[c.tier.tier]++);
      addLog(`Found ${dupes.length} duplicate pairs`, dupes.length > 0 ? 'warning' : 'success');
      addLog(`  Tier 1 (Definitive): ${byTier[1]}`, 'info');
      addLog(`  Tier 2 (Strong): ${byTier[2]}`, 'info');
      addLog(`  Tier 3 (Possible): ${byTier[3]}`, 'info');
      addLog(`  Tier 4 (Conflicts): ${byTier[4]}`, byTier[4] > 0 ? 'error' : 'info');
    } catch (err) {
      addLog(`Error: ${err.message}`, 'error');
    } finally {
      setLoading(false);
    }
  };

  const handleMergeComplete = (historyEntry) => {
    addLog(`Merge ${historyEntry.merge_id} completed!`, 'success');
    setSelectedCandidate(null);
    setCandidates(prev => prev.filter(c => c.id !== selectedCandidate.id));
  };

  const filteredCandidates = useMemo(() => {
    let result = [...candidates];
    if (tierFilter !== 'all') result = result.filter(c => c.tier.tier === parseInt(tierFilter));
    if (searchFilter.trim()) {
      const q = searchFilter.toLowerCase();
      result = result.filter(c =>
        c.survivor.name.toLowerCase().includes(q) ||
        c.merged.name.toLowerCase().includes(q) ||
        c.survivor.record.id.includes(q) ||
        c.merged.record.id.includes(q)
      );
    }
    return result;
  }, [candidates, tierFilter, searchFilter]);

  const stats = useMemo(() => ({
    total: allRecords.length,
    candidates: candidates.length,
    byTier: { 1: candidates.filter(c => c.tier.tier === 1).length, 2: candidates.filter(c => c.tier.tier === 2).length,
              3: candidates.filter(c => c.tier.tier === 3).length, 4: candidates.filter(c => c.tier.tier === 4).length }
  }), [allRecords, candidates]);

  return (
    <div className="container">
      <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'flex-start', flexWrap: 'wrap', gap: '10px', marginBottom: '20px' }}>
        <div>
          <h1>Airtable Dedupe</h1>
          <p className="subtitle">Client Deduplication with Tiered Matching</p>
        </div>
        <div style={{ display: 'flex', alignItems: 'center', gap: '10px' }}>
          <span style={{ background: isBahrOnly ? '#6366f1' : '#10b981', color: 'white', padding: '6px 12px', borderRadius: '6px', fontSize: '0.85em' }}>
            {isBahrOnly ? 'Bahr Clients' : 'All Clients'}
          </span>
          <button onClick={onLogout} className="secondary small">Logout</button>
        </div>
      </div>

      <div className="tabs">
        <div className={`tab ${activeTab === 'scan' ? 'active' : ''}`} onClick={() => setActiveTab('scan')}>
          Scan & Review ({candidates.length})
        </div>
        <div className={`tab ${activeTab === 'history' ? 'active' : ''}`} onClick={() => setActiveTab('history')}>
          History
        </div>
      </div>

      {activeTab === 'scan' && (
        <>
          <div className="card">
            <h2>Airtable Connection</h2>
            <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: '15px' }}>
              <div className="input-group">
                <label>API Key (Personal Access Token)</label>
                <input type="password" value={apiKey} onChange={e => setApiKey(e.target.value)} placeholder="pat_..." />
              </div>
              <div className="input-group">
                <label>Base ID</label>
                <input type="text" value={baseId} onChange={e => setBaseId(e.target.value)} placeholder="app..." />
              </div>
            </div>
            <div className="btn-group">
              <button className="primary" onClick={fetchAndScan} disabled={loading || !apiKey}>
                {loading ? 'Scanning...' : 'Fetch & Scan for Duplicates'}
              </button>
            </div>
          </div>

          {candidates.length > 0 && (
            <div className="stats-grid">
              <div className="stat-card"><div className="number">{stats.total}</div><div className="label">Total Records</div></div>
              <div className="stat-card tier1"><div className="number">{stats.byTier[1]}</div><div className="label">Tier 1 Definitive</div></div>
              <div className="stat-card tier2"><div className="number">{stats.byTier[2]}</div><div className="label">Tier 2 Strong</div></div>
              <div className="stat-card tier3"><div className="number">{stats.byTier[3]}</div><div className="label">Tier 3 Possible</div></div>
              <div className="stat-card tier4"><div className="number">{stats.byTier[4]}</div><div className="label">Tier 4 Conflicts</div></div>
            </div>
          )}

          {candidates.length > 0 && (
            <div className="card">
              <h2>Duplicate Candidates ({filteredCandidates.length})</h2>
              <div className="filter-controls">
                <select value={tierFilter} onChange={e => setTierFilter(e.target.value)}>
                  <option value="all">All Tiers</option>
                  <option value="1">Tier 1 - Definitive</option>
                  <option value="2">Tier 2 - Strong</option>
                  <option value="3">Tier 3 - Possible</option>
                  <option value="4">Tier 4 - Conflicts</option>
                </select>
                <input type="text" value={searchFilter} onChange={e => setSearchFilter(e.target.value)} placeholder="Search by name or ID..." />
              </div>
              <div className="table-container">
                <table>
                  <thead>
                    <tr>
                      <th>Confidence</th>
                      <th>Keep (Record A)</th>
                      <th>Merge (Record B)</th>
                      <th>Match Reasons</th>
                      <th>Action</th>
                    </tr>
                  </thead>
                  <tbody>
                    {filteredCandidates.map(c => (
                      <tr key={c.id} className="clickable" onClick={() => setSelectedCandidate(c)}>
                        <td>
                          <span className={`badge tier${c.tier.tier}`}>{c.confidence}%</span>
                          <div style={{ fontSize: '0.75em', color: '#94a3b8' }}>{c.tier.name}</div>
                        </td>
                        <td>
                          <div style={{ fontWeight: '500' }}>{c.survivor.name}</div>
                          <div style={{ fontSize: '0.75em', color: '#94a3b8' }}>Score: {c.survivor.score}</div>
                        </td>
                        <td>
                          <div>{c.merged.name}</div>
                          <div style={{ fontSize: '0.75em', color: '#94a3b8' }}>Score: {c.merged.score}</div>
                        </td>
                        <td>
                          {c.reasons.slice(0, 2).map((r, i) => <span key={i} className="reason-tag">{r}</span>)}
                          {c.reasons.length > 2 && <span className="reason-tag">+{c.reasons.length - 2}</span>}
                          {c.conflicts?.map((cf, i) => <span key={i} className="reason-tag conflict">{cf}</span>)}
                        </td>
                        <td><button className="primary small">Review</button></td>
                      </tr>
                    ))}
                  </tbody>
                </table>
              </div>
            </div>
          )}

          {allRecords.length > 0 && candidates.length === 0 && (
            <div className="card" style={{ textAlign: 'center' }}>
              <h2 style={{ color: '#10b981' }}>No Duplicates Found</h2>
              <p>All {allRecords.length} records appear to be unique.</p>
            </div>
          )}
        </>
      )}

      {activeTab === 'history' && <HistoryViewer credentials={credentials} addLog={addLog} />}

      <div className="card">
        <h2>Activity Log</h2>
        <div className="log-container" ref={logRef}>
          {logs.length === 0 ? (
            <div className="log-entry info">Ready - configure connection and click Scan</div>
          ) : (
            logs.map((log, idx) => (
              <div key={idx} className={`log-entry ${log.type}`}>[{log.timestamp}] {log.message}</div>
            ))
          )}
        </div>
        {logs.length > 0 && <button className="warning small" onClick={() => setLogs([])} style={{ marginTop: '10px' }}>Clear</button>}
      </div>

      {selectedCandidate && (
        <MergeReviewModal
          candidate={selectedCandidate}
          schema={schema}
          credentials={credentials}
          onComplete={handleMergeComplete}
          onSkip={() => { setCandidates(prev => prev.filter(c => c.id !== selectedCandidate.id)); setSelectedCandidate(null); }}
          onClose={() => setSelectedCandidate(null)}
          addLog={addLog}
        />
      )}
    </div>
  );
}

ReactDOM.createRoot(document.getElementById('root')).render(<App />);
  </script>
</body>
</html>
